<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE doc SYSTEM "doc.dtd">
<doc title="Guide de l'utilisateur {[project]}" subtitle="{[user-guide-subtitle]} / {[postgres]} {[pg-version]}" cmd-line-len="85">
    <description>Le guide de l'utilisateur de {[project]} vous montre comment configurer rapidement et facilement {[project]} avec votre instance de base de données {[postgres]}. Des instructions pas à pas guident l'utilisateur à travers toutes les caractéristiques importantes de la solution de sauvegarde et de restauration pour {[postgres]} la plus rapide et la plus fiable.</description>

    <!-- Variables used by the rest of the script -->
    <variable-list>
        <!-- Defined OS types -->
        <variable key="os-debian">debian</variable>
        <variable key="os-centos6">centos6</variable>
        <variable key="os-centos7">centos7</variable>

        <!-- OS titles -->
        <variable key="os-debian-title">Debian &amp; Ubuntu</variable>
        <variable key="os-centos6-title">RHEL &amp; CentOS 6</variable>
        <variable key="os-centos7-title">RHEL &amp; CentOS 7</variable>

        <!-- Base PostgreSQL versions -->
        <variable key="os-debian-pg-version">10</variable>
        <variable key="os-centos6-pg-version">9.5</variable>
        <variable key="os-centos7-pg-version">9.6</variable>

        <!-- User-defined package to use in documentation (use "apt" to install the current PGDG apt package) -->
        <variable key="package">none</variable>

        <!-- Defines the general OS type that will be used to generate commands.  Also supported: centos6, centos7 -->
        <variable key="os-type">debian</variable>

        <!-- Will encryption be used in the documentation? It can be useful for testing to omit encryption. -->
        <variable key="encrypt">y</variable>

        <!-- Common if expressions for testing os-type -->
        <variable key="os-type-is-debian">'{[os-type]}' eq '{[os-debian]}'</variable>
        <variable key="os-type-is-centos6">'{[os-type]}' eq '{[os-centos6]}'</variable>
        <variable key="os-type-is-centos7">'{[os-type]}' eq '{[os-centos7]}'</variable>
        <variable key="os-type-is-centos">({[os-type-is-centos6]} || {[os-type-is-centos7]})</variable>

        <!-- Defines the container image that will be used to build the host -->
        <variable key="os-image" if="{[os-type-is-debian]}">ubuntu:16.04</variable>
        <variable key="os-image" if="{[os-type-is-centos6]}">centos:6</variable>
        <variable key="os-image" if="{[os-type-is-centos7]}">centos:7</variable>

        <variable key="user-guide-subtitle" if="{[os-type-is-debian]}">{[os-debian-title]}</variable>
        <variable key="user-guide-subtitle" if="{[os-type-is-centos6]}">{[os-centos6-title]}</variable>
        <variable key="user-guide-subtitle" if="{[os-type-is-centos7]}">{[os-centos7-title]}</variable>

        <variable key="user-guide-os" if="{[os-type-is-debian]}">Debian/Ubuntu</variable>
        <variable key="user-guide-os" if="{[os-type-is-centos6]}">RHEL/CentOS 6</variable>
        <variable key="user-guide-os" if="{[os-type-is-centos7]}">RHEL/CentOS 7</variable>

        <variable key="pgbackrest-repo-path">/pgbackrest</variable>

        <!-- Path where CA certificates are installed -->
        <variable key="ca-cert-path" if="{[os-type-is-debian]}">/usr/local/share/ca-certificates</variable>
        <variable key="ca-cert-path" if="{[os-type-is-centos]}">/etc/pki/ca-trust/source/anchors</variable>

        <!-- Path where fake certificates are located -->
        <variable key="fake-cert-path-relative">resource/fake-cert</variable>
        <variable key="fake-cert-path">{[host-repo-path]}/doc/{[fake-cert-path-relative]}</variable>

        <variable key="pg-version" if="{[os-type-is-debian]}">{[os-debian-pg-version]}</variable>
        <variable key="pg-version" if="{[os-type-is-centos6]}">{[os-centos6-pg-version]}</variable>
        <variable key="pg-version" if="{[os-type-is-centos7]}">{[os-centos7-pg-version]}</variable>
        <variable key="pg-version-nodot" eval="y">my $version = '{[pg-version]}'; $version =~ s/\.//g; return $version;</variable>

        <!-- WAL level should be the minimum required for replication -->
        <variable key="wal-level" if="{[pg-version]} &lt; 9.6">hot_standby</variable>
        <variable key="wal-level" if="{[pg-version]} &gt;= 9.6">replica</variable>

        <variable key="pg-version-upgrade" if="{[os-type-is-debian]}">11</variable>
        <variable key="pg-version-upgrade" if="{[os-type-is-centos6]}">9.6</variable>
        <variable key="pg-version-upgrade" if="{[os-type-is-centos7]}">10</variable>
        <variable key="pg-version-upgrade-nodot" eval="y">my $version = '{[pg-version-upgrade]}'; $version =~ s/\.//g; return $version;</variable>

        <variable key="pg-bin-path" if="{[os-type-is-debian]}">/usr/lib/postgresql/{[pg-version]}/bin</variable>
        <variable key="pg-bin-path" if="{[os-type-is-centos]}">/usr/pgsql-{[pg-version]}/bin</variable>

        <variable key="pg-bin-upgrade-path" if="{[os-type-is-debian]}">/usr/lib/postgresql/{[pg-version-upgrade]}/bin</variable>
        <variable key="pg-bin-upgrade-path" if="{[os-type-is-centos]}">/usr/pgsql-{[pg-version-upgrade]}/bin</variable>

        <variable key="pg-home-path" if="{[os-type-is-debian]}">/var/lib/postgresql</variable>
        <variable key="pg-home-path" if="{[os-type-is-centos]}">/var/lib/pgsql</variable>

        <variable key="pg-group">postgres</variable>

        <variable key="backrest-repo-path">/var/lib/pgbackrest</variable>
        <variable key="backrest-repo-cipher-type">aes-256-cbc</variable>
        <variable key="backrest-repo-cipher-pass">zWaf6XtpjIVZC5444yXB+cgFDFl7MxGlgkZSaoPvTGirhPygu4jOKOXf9LO4vjfO</variable>
        <variable key="br-bin">/usr/bin/pgbackrest</variable>
        <variable key="br-user">pgbackrest</variable>
        <variable key="br-group">{[br-user]}</variable>
        <variable key="br-home-path">/home/{[br-user]}</variable>

        <variable key="postgres-cluster-demo">demo</variable>
        <variable key="backrest-config-path">/etc/{[project-exe]}</variable>
        <variable key="backrest-config-include-path">{[backrest-config-path]}/conf.d</variable>
        <variable if="'{[package]}' eq 'none'" key="backrest-config-demo">{[backrest-config-path]}/{[project-exe]}.conf</variable>
        <variable if="'{[package]}' ne 'none'" key="backrest-config-demo">/etc/{[project-exe]}.conf</variable>

        <variable key="pg-path-default" if="{[os-type-is-debian]}">/var/lib/postgresql/[version]/[cluster]</variable>
        <variable key="pg-path-default" if="{[os-type-is-centos]}">/var/lib/pgsql/[version]/data</variable>

        <variable key="pg-path" if="{[os-type-is-debian]}">/var/lib/postgresql/{[pg-version]}/{[postgres-cluster-demo]}</variable>
        <variable key="pg-path" if="{[os-type-is-centos]}">/var/lib/pgsql/{[pg-version]}/data</variable>

        <variable key="pg-path-upgrade" if="{[os-type-is-debian]}">/var/lib/postgresql/{[pg-version-upgrade]}/{[postgres-cluster-demo]}</variable>
        <variable key="pg-path-upgrade" if="{[os-type-is-centos]}">/var/lib/pgsql/{[pg-version-upgrade]}/data</variable>

        <variable key="spool-path">/var/spool/pgbackrest</variable>

        <variable key="postgres-config-demo" if="{[os-type-is-debian]}">/etc/postgresql/{[pg-version]}/{[postgres-cluster-demo]}/postgresql.conf</variable>
        <variable key="postgres-config-demo" if="{[os-type-is-centos]}">{[pg-path]}/postgresql.conf</variable>

        <variable key="postgres-config-demo-upgrade" if="{[os-type-is-debian]}">/etc/postgresql/{[pg-version-upgrade]}/{[postgres-cluster-demo]}/postgresql.conf</variable>
        <variable key="postgres-config-demo-upgrade" if="{[os-type-is-centos]}">{[pg-path-upgrade]}/postgresql.conf</variable>

        <variable key="postgres-hba-demo" if="{[os-type-is-debian]}">/etc/postgresql/{[pg-version]}/{[postgres-cluster-demo]}/pg_hba.conf</variable>
        <variable key="postgres-hba-demo" if="{[os-type-is-centos]}">{[pg-path]}/pg_hba.conf</variable>

        <variable key="postgres-hba-demo-upgrade" if="{[os-type-is-debian]}">/etc/postgresql/{[pg-version-upgrade]}/{[postgres-cluster-demo]}/pg_hba.conf</variable>
        <variable key="postgres-hba-demo-upgrade" if="{[os-type-is-centos]}">{[pg-path-upgrade]}/pg_hba.conf</variable>

        <variable key="postgres-pgpass">{[pg-home-path]}/.pgpass</variable>

        <variable key="postgres-log-demo" if="{[os-type-is-debian]}">/var/log/postgresql/postgresql-{[pg-version]}-{[postgres-cluster-demo]}.log</variable>
        <variable key="postgres-log-demo" if="{[os-type-is-centos]}">{[pg-path]}/pg_log/postgresql.log</variable>

        <variable key="postgres-log-pgstartup-demo" if="{[os-type-is-centos]}">/var/lib/pgsql/{[pg-version]}/pgstartup.log</variable>

        <variable key="postgres-recovery-demo" if="{[pg-version]} &lt; 12">{[pg-path]}/recovery.conf</variable>
        <variable key="postgres-recovery-demo" if="{[pg-version]} &gt;= 12">{[pg-path]}/postgresql.auto.conf</variable>

        <!-- Select correct WAL switch function based on the version of PostgreSQL -->
        <variable key="pg-switch-wal" if="{[pg-version]} &lt; 10">pg_switch_xlog</variable>
        <variable key="pg-switch-wal" if="{[pg-version]} &gt;= 10">pg_switch_wal</variable>

        <!-- S3 Settings -->
        <variable key="s3-all">n</variable>                         <!-- Build all the documentation with S3? -->
        <variable key="s3-local">y</variable>
        <variable key="s3-bucket">demo-bucket</variable>
        <variable key="s3-repo">demo-repo</variable>
        <variable key="s3-region">us-east-1</variable>
        <variable key="s3-endpoint">s3.{[s3-region]}.amazonaws.com</variable>
        <variable key="s3-key">accessKey1</variable>
        <variable key="s3-key-secret">verySecretKey1</variable>

        <!-- Hosts -->
        <variable key="host-image">pgbackrest/doc:{[os-type]}</variable>

        <variable key="host-option">-v /sys/fs/cgroup:/sys/fs/cgroup:rw -v /tmp/$(mktemp -d):/run</variable>

        <variable key="host-user" eval="y">use English; getpwuid($UID) eq 'root' ? 'vagrant' : getpwuid($UID) . ''</variable>
        <variable key="host-mount">{[host-repo-path]}:{[pgbackrest-repo-path]}</variable>
        <variable key="image-repo">pgbackrest/test</variable>

        <variable key="host-s3-id">s3</variable>
        <variable key="host-s3">s3-server</variable>

        <variable key="host-pg1-id">pg1</variable>
        <variable key="host-pg1">pg-primary</variable>
        <variable key="host-pg1-user">{[host-user]}</variable>
        <variable key="host-pg1-image">{[host-image]}</variable>
        <variable key="host-pg1-mount">{[host-mount]}</variable>

        <variable key="host-build-id">build</variable>
        <variable key="host-build">build</variable>
        <variable key="host-build-user">{[host-user]}</variable>
        <variable key="host-build-image">{[host-image]}</variable>
        <variable key="host-build-mount">{[host-mount]}</variable>

        <variable key="host-pg2-id">pg2</variable>
        <variable key="host-pg2">pg-standby</variable>
        <variable key="host-pg2-user">{[host-pg1-user]}</variable>
        <variable key="host-pg2-image">{[host-image]}</variable>
        <variable key="host-pg2-mount">{[host-mount]}</variable>

        <variable key="host-repo1-id">repo1</variable>
        <variable key="host-repo1">repository</variable>
        <variable key="host-repo1-user">{[host-user]}</variable>
        <variable key="host-repo1-image">{[host-image]}</variable>
        <variable key="host-repo1-mount">{[host-mount]}</variable>

        <!-- Commands for various operations -->
        <variable key="cmd-backup-last">pgbackrest repo-ls backup/demo --filter="(F|D|I)$" --sort=desc | head -1</variable>

        <!-- Data used to demonstrate backup/restore operations -->
        <variable key="test-table-data">Important Data</variable>

        <!-- Database cluster commmands -->
        <variable key="pg-cluster-wait">sleep 2</variable>

        <variable key="pg-cluster-create" if="{[os-type-is-debian]}">pg_createcluster {[pg-version]} {[postgres-cluster-demo]}</variable>

        <variable key="pg-cluster-create-upgrade" if="{[os-type-is-debian]}">pg_createcluster {[pg-version-upgrade]} {[postgres-cluster-demo]}</variable>

        <variable key="pg-cluster-start" if="{[os-type-is-debian]}">pg_ctlcluster {[pg-version]} {[postgres-cluster-demo]} start</variable>
        <variable key="pg-cluster-start" if="{[os-type-is-centos6]}">service postgresql-{[pg-version]} start</variable>
        <variable key="pg-cluster-start" if="{[os-type-is-centos7]}">systemctl start postgresql-{[pg-version]}.service</variable>

        <variable key="pg-cluster-start-upgrade" if="{[os-type-is-debian]}">pg_ctlcluster {[pg-version-upgrade]} {[postgres-cluster-demo]} start</variable>
        <variable key="pg-cluster-start-upgrade" if="{[os-type-is-centos6]}">service postgresql-{[pg-version-upgrade]} start</variable>
        <variable key="pg-cluster-start-upgrade" if="{[os-type-is-centos7]}">systemctl start postgresql-{[pg-version-upgrade]}.service</variable>

        <variable key="pg-cluster-stop" if="{[os-type-is-debian]}">pg_ctlcluster {[pg-version]} {[postgres-cluster-demo]} stop</variable>
        <variable key="pg-cluster-stop" if="{[os-type-is-centos6]}">service postgresql-{[pg-version]} stop</variable>
        <variable key="pg-cluster-stop" if="{[os-type-is-centos7]}">systemctl stop postgresql-{[pg-version]}.service</variable>

        <variable key="pg-cluster-restart" if="{[os-type-is-debian]}">pg_ctlcluster {[pg-version]} {[postgres-cluster-demo]} restart</variable>
        <variable key="pg-cluster-restart" if="{[os-type-is-centos6]}">service postgresql-{[pg-version]} restart</variable>
        <variable key="pg-cluster-restart" if="{[os-type-is-centos7]}">systemctl restart postgresql-{[pg-version]}.service</variable>

        <variable key="pg-cluster-reload" if="{[os-type-is-debian]}">pg_ctlcluster {[pg-version]} {[postgres-cluster-demo]} reload</variable>
        <variable key="pg-cluster-reload" if="{[os-type-is-centos6]}">service postgresql-{[pg-version]} reload</variable>
        <variable key="pg-cluster-reload" if="{[os-type-is-centos7]}">systemctl reload postgresql-{[pg-version]}.service</variable>

        <variable key="pg-cluster-check" if="{[os-type-is-debian]}">pg_lsclusters</variable>
        <variable key="pg-cluster-check" if="{[os-type-is-centos6]}">service postgresql-{[pg-version]} status</variable>
        <variable key="pg-cluster-check" if="{[os-type-is-centos7]}">systemctl status postgresql-{[pg-version]}.service</variable>

        <variable key="pg-cluster-check-upgrade" if="{[os-type-is-debian]}">pg_lsclusters</variable>
        <variable key="pg-cluster-check-upgrade" if="{[os-type-is-centos6]}">service postgresql-{[pg-version-upgrade]} status</variable>
        <variable key="pg-cluster-check-upgrade" if="{[os-type-is-centos7]}">systemctl status postgresql-{[pg-version-upgrade]}.service</variable>

        <!-- Add more tables to make the backup more interesting. This is a rough and ready solution that can be pasted into the
             document where needed to grow the number of files as needed for performance testing. -->
        <!-- <execute user="postgres" show="n">
            <exe-cmd>psql -c "
                create or replace function create_test_table(prefix int, scale int) returns void as \$\$
                declare
                    index int;
                begin
                    for index in 1 .. scale loop
                        execute 'create table test_' || prefix || '_' || index || ' (id int)';
                    end loop;
                end \$\$ LANGUAGE plpgsql;"</exe-cmd>
        </execute>

        <execute user="postgres" show="n">
            <exe-cmd>
                bash -c 'for i in {1..100}; do psql -c "select create_test_table(${i?}, 1000)"; done'
            </exe-cmd>
        </execute> -->

        <!-- Common commands -->
        <variable key="ssh-key-install">
            mkdir -p -m 700 /root/.ssh &amp;&amp; \
            echo '-----BEGIN RSA PRIVATE KEY-----' > /root/.ssh/id_rsa &amp;&amp; \
            echo 'MIICXwIBAAKBgQDR0yJsZW5d5LcqteiOtv8d+FFeFFHDPI0VTcTOdMn1iDiIP1ou' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'X3Q2OyNjsBaDbsRJd+sp9IRq1LKX3zsBcgGZANwm0zduuNEPEU94ajS/uRoejIqY' >> /root/.ssh/id_rsa &amp;&amp; \
            echo '/XkKOpnEF6ZbQ2S7TaE4sWeGLvba7kUFs0QTOO+N+nV2dMbdqZf6C8lazwIDAQAB' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'AoGBAJXa6xzrnFVmwgK5BKzYuX/YF5TPgk2j80ch0ct50buQXH/Cb0/rUH5i4jWS' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'T6Hy/DFUehnuzpvV6O9auTOhDs3BhEKFRuRLn1nBwTtZny5Hh+cw7azUCEHFCJlz' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'makCrVbgawtno6oU/pFgQm1FcxD0f+Me5ruNcLHqUZsPQwkRAkEA+8pG+ckOlz6R' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'AJLIHedmfcrEY9T7sfdo83bzMOz8H5soUUP4aOTLJYCla1LO7JdDnXMGo0KxaHBP' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'l8j5zDmVewJBANVVPDJr1w37m0FBi37QgUOAijVfLXgyPMxYp2uc9ddjncif0063' >> /root/.ssh/id_rsa &amp;&amp; \
            echo '0Wc0FQefoPszf3CDrHv/RHvhHq97jXDwTb0CQQDgH83NygoS1r57pCw9chzpG/R0' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'aMEiSPhCvz757fj+qT3aGIal2AJ7/2c/gRZvwrWNETZ3XIZOUKqIkXzJLPjBAkEA' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'wnP799W2Y8d4/+VX2pMBkF7lG7sSviHEq1sP2BZtPBRQKSQNvw3scM7XcGh/mxmY' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'yx0qpqfKa8SKbNgI1+4iXQJBAOlg8MJLwkUtrG+p8wf69oCuZsnyv0K6UMDxm6/8' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'cbvfmvODulYFaIahaqHWEZoRo5CLYZ7gN43WHPOrKxdDL78=' >> /root/.ssh/id_rsa &amp;&amp; \
            echo '-----END RSA PRIVATE KEY-----' >> /root/.ssh/id_rsa &amp;&amp; \
            echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDR0yJsZW5d5LcqteiOtv8d+FFeFFHDPI0VTcTOdMn1iDiIP1ouX3Q2OyNjsBaDbsRJd+sp9IRq1LKX3zsBcgGZANwm0zduuNEPEU94ajS/uRoejIqY/XkKOpnEF6ZbQ2S7TaE4sWeGLvba7kUFs0QTOO+N+nV2dMbdqZf6C8lazw== root@pgbackrest-doc' > /root/.ssh/authorized_keys &amp;&amp; \
            echo 'Host *' > /root/.ssh/config &amp;&amp; \
            echo '    StrictHostKeyChecking no' >> /root/.ssh/config &amp;&amp; \
            chmod 600 /root/.ssh/*
        </variable>

        <variable key="copy-ca-cert">COPY {[fake-cert-path-relative]}/ca.crt {[ca-cert-path]}/pgbackrest-ca.crt</variable>

        <!-- Don't allow sudo to disable core dump (suppresses errors, see https://github.com/sudo-project/sudo/issues/42) -->
        <variable key="sudo-disable-core-dump">RUN echo "Set disable_coredump false" >> /etc/sudo.conf</variable>
    </variable-list>

    <!-- Setup hosts used to build the documentation
    ============================================================================================================================ -->
    <host-define if="{[os-type-is-debian]}" image="{[host-image]}" from="{[os-image]}">
        {[copy-ca-cert]}

        # Fix root tty
        RUN sed -i 's/^mesg n/tty -s \&amp;\&amp; mesg n/g' /root/.profile

        # Install base packages (suppress dpkg interactive output)
        RUN export DEBIAN_FRONTEND=noninteractive &amp;&amp; \
            rm /etc/apt/apt.conf.d/70debconf &amp;&amp; \
            apt-get update &amp;&amp; \
            apt-get install -y sudo ssh wget vim gnupg lsb-release iputils-ping ca-certificates tzdata locales 2>&amp;1

        {[sudo-disable-core-dump]}

        # Install CA certificate
        RUN update-ca-certificates

        # Install PostgreSQL
        RUN RELEASE_CODENAME=`lsb_release -c | awk '{print $2}'` &amp;&amp; \
            echo 'deb http://apt.postgresql.org/pub/repos/apt/ '${RELEASE_CODENAME?}'-pgdg main' | \
                tee -a /etc/apt/sources.list.d/pgdg.list &amp;&amp; \
            wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - &amp;&amp; \
            apt-get update &amp;&amp; \
            apt-get install -y postgresql-common 2>&amp;1 &amp;&amp; \
            sed -i 's/^\#create\_main\_cluster.*$/create\_main\_cluster \= false/' \
                /etc/postgresql-common/createcluster.conf &amp;&amp; \
            apt-get install -y postgresql-{[pg-version]} postgresql-{[pg-version-upgrade]} 2>&amp;1

        # Create an ssh key for root so all hosts can ssh to each other as root
        RUN \ {[ssh-key-install]}

        # Add doc user with sudo privileges
        RUN adduser --disabled-password --gecos "" {[host-user]} &amp;&amp; \
            echo '%{[host-user]} ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers

        # Set UTF8 encoding
        RUN sed -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen &amp;&amp; \
            dpkg-reconfigure --frontend=noninteractive locales &amp;&amp; \
            update-locale LANG=en_US.UTF-8
        ENV LANG en_US.UTF-8

        ENTRYPOINT service ssh restart &amp;&amp; bash
    </host-define>

    <host-define if="{[os-type-is-centos6]}" image="{[host-image]}" from="{[os-image]}">
        {[copy-ca-cert]}

        # Install packages
        RUN yum install -y openssh-server openssh-clients sudo wget vim 2>&amp;1

        {[sudo-disable-core-dump]}

        # Install CA certificate
        RUN update-ca-trust enable &amp;&amp; \
            update-ca-trust extract

        # Regenerate SSH keys
        RUN rm -f /etc/ssh/ssh_host_rsa_key* &amp;&amp; \
            ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key

        # Install PostgreSQL
        RUN rpm --import http://yum.postgresql.org/RPM-GPG-KEY-PGDG-10 &amp;&amp; \
            rpm -ivh https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-6-x86_64/pgdg-redhat-repo-latest.noarch.rpm &amp;&amp; \
            yum install -y postgresql{[pg-version-nodot]}-server postgresql{[pg-version-upgrade-nodot]}-server

        # Create an ssh key for root so all hosts can ssh to each other as root
        RUN \ {[ssh-key-install]}

        # Add doc user with sudo privileges
        RUN adduser -n {[host-user]} &amp;&amp; \
            echo '{[host-user]}        ALL=(ALL)       NOPASSWD: ALL' > /etc/sudoers.d/{[host-user]}

        ENTRYPOINT /usr/sbin/sshd -D
    </host-define>

    <host-define if="{[os-type-is-centos7]}" image="{[host-image]}" from="{[os-image]}">
        ENV container docker

        {[copy-ca-cert]}

        RUN (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == \
            systemd-tmpfiles-setup.service ] || rm -f $i; done); \
            rm -f /lib/systemd/system/multi-user.target.wants/*;\
            rm -f /etc/systemd/system/*.wants/*;\
            rm -f /lib/systemd/system/local-fs.target.wants/*; \
            rm -f /lib/systemd/system/sockets.target.wants/*udev*; \
            rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \
            rm -f /lib/systemd/system/basic.target.wants/*;\
            rm -f /lib/systemd/system/anaconda.target.wants/*;

        VOLUME [ "/sys/fs/cgroup" ]

        # Install packages
        RUN yum install -y openssh-server openssh-clients sudo wget vim 2>&amp;1

        # Install CA certificate
        RUN update-ca-trust extract

        # Regenerate SSH keys
        RUN rm -f /etc/ssh/ssh_host_rsa_key* &amp;&amp; \
            ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key &amp;&amp; \
            rm -f /etc/ssh/ssh_host_dsa_key* &amp;&amp; \
            ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key

        # Install PostgreSQL
        RUN rpm --import http://yum.postgresql.org/RPM-GPG-KEY-PGDG-10 &amp;&amp; \
            rpm -ivh https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm  &amp;&amp; \
            yum install -y postgresql{[pg-version-nodot]}-server postgresql{[pg-version-upgrade-nodot]}-server

        # Create an ssh key for root so all hosts can ssh to each other as root
        RUN \ {[ssh-key-install]}

        # Add doc user with sudo privileges
        RUN adduser -n {[host-user]} &amp;&amp; \
            echo '{[host-user]}        ALL=(ALL)       NOPASSWD: ALL' > /etc/sudoers.d/{[host-user]}

        # Enable the user session service so logons are allowed
        RUN systemctl enable systemd-user-sessions.service &amp;&amp; \
            ln -s /usr/lib/systemd/system/systemd-user-sessions.service \
                /etc/systemd/system/default.target.wants/systemd-user-sessions.service

        CMD ["/usr/sbin/init"]
    </host-define>

    <!-- ======================================================================================================================= -->
    <block-define id="setup-ssh-intro">
        <p><backrest/> nécessite un configuration de SSH sans mot de passe (par échange de clef) pour permettre la communication entre les hôtes.</p>
    </block-define>

    <block-define id="setup-ssh">
        <execute-list host="{[setup-ssh-host]}">
            <title>Créer sur <host>{[setup-ssh-host]}</host> une paire de clef</title>

            <execute user="{[setup-ssh-user]}">
                <exe-cmd>mkdir -m 750 -p {[setup-ssh-user-home-path]}/.ssh</exe-cmd>
            </execute>
            <execute user="{[setup-ssh-user]}">
                <exe-cmd>ssh-keygen -f {[setup-ssh-user-home-path]}/.ssh/id_rsa
                    -t rsa -b 4096 -N ""</exe-cmd>
            </execute>
        </execute-list>

        <p>Echange de clef entre <host>{[host-repo1]}</host> et <host>{[setup-ssh-host]}</host>.</p>

        <execute-list host="{[host-repo1]}">
            <title>Copiez la clef public de <host>{[setup-ssh-host]}</host> sur <host>{[host-repo1]}</host></title>

            <execute user="root" err-suppress="y" user-force="y">
                <exe-cmd>
                    (echo -n 'no-agent-forwarding,no-X11-forwarding,no-port-forwarding,' &amp;&amp;
                    echo -n 'command="{[br-bin]} ${SSH_ORIGINAL_COMMAND#* }" ' &amp;&amp;
                    sudo ssh root@{[setup-ssh-host]} cat {[setup-ssh-user-home-path]}/.ssh/id_rsa.pub) |
                    sudo -u pgbackrest tee -a {[br-home-path]}/.ssh/authorized_keys
                </exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[setup-ssh-host]}">
            <title>Copiez la clef publique de <host>{[host-repo1]}</host> sur <host>{[setup-ssh-host]}</host></title>

            <execute user="root" err-suppress="y" user-force="y">
                <exe-cmd>
                    (echo -n 'no-agent-forwarding,no-X11-forwarding,no-port-forwarding,' &amp;&amp;
                    echo -n 'command="{[br-bin]} ${SSH_ORIGINAL_COMMAND#* }" ' &amp;&amp;
                    sudo ssh root@{[host-repo1]} cat {[br-home-path]}/.ssh/id_rsa.pub) |
                    sudo -u {[setup-ssh-user]} tee -a {[setup-ssh-user-home-path]}/.ssh/authorized_keys
                </exe-cmd>
            </execute>
        </execute-list>

        <p>Testez que la connexion SSH fonctionne entre <host>{[host-repo1]}</host> et <host>{[setup-ssh-host]}</host> et vice versa.</p>

        <execute-list host="{[host-repo1]}">
            <title>Testez la connexon depuis <host>{[host-repo1]}</host> vers <host>{[setup-ssh-host]}</host></title>

            <execute user="{[br-user]}" err-suppress="y">
                <exe-cmd>ssh {[setup-ssh-user]}@{[setup-ssh-host]}</exe-cmd>
                <exe-cmd-extra>-o StrictHostKeyChecking=no</exe-cmd-extra>
            </execute>
        </execute-list>

        <execute-list host="{[setup-ssh-host]}">
            <title>Teste de la connexion depuis <host>{[setup-ssh-host]}</host> vers <host>{[host-repo1]}</host></title>

            <execute user="{[setup-ssh-user]}" err-suppress="y">
                <exe-cmd>ssh pgbackrest@{[host-repo1]}</exe-cmd>
                <exe-cmd-extra>-o StrictHostKeyChecking=no</exe-cmd-extra>
            </execute>
        </execute-list>
    </block-define>

    <!-- ======================================================================================================================= -->
    <block-define if="'{[package]}' eq 'none'" id="br-install">
        <p><backrest/> doit être installé à partir d'un paquet ou installé manuellement comme indiqué ci-dessous.</p>

        <execute-list host="{[host-build]}">
            <title>Installation des dépendances</title>

            <execute if="{[os-type-is-debian]}" user="root" pre="y">
                <exe-cmd>
                    apt-get install postgresql-client libxml2</exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>

            <execute if="{[os-type-is-centos]}" user="root" pre="y">
                <exe-cmd>
                    yum install postgresql-libs
                </exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>
        </execute-list>

        <execute-list host="{[br-install-host]}">
            <title>Copiez les binaires de <backrest/> depuis la plateforme de compilation</title>

            <execute user="root">
                <exe-cmd>scp {[host-build]}:/build/pgbackrest-release-{[version]}/src/pgbackrest /usr/bin</exe-cmd>
                <exe-cmd-extra>2>&amp;1</exe-cmd-extra>
            </execute>

            <execute user="root">
                <exe-cmd>chmod 755 /usr/bin/pgbackrest</exe-cmd>
            </execute>
        </execute-list>

        <p><backrest/> nécessite des répertoires pour les traces (logs) et pour la configuration ainsi qu'un fichier de configuration.</p>

        <execute-list host="{[br-install-host]}">
            <title>Création des répertoires et du fichier de configuration pour <backrest/></title>

            <execute user="root">
                <exe-cmd>mkdir -p -m 770 /var/log/pgbackrest</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chown {[br-install-user]}:{[br-install-group]} /var/log/pgbackrest</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>mkdir -p {[backrest-config-path]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>mkdir -p {[backrest-config-include-path]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>touch {[backrest-config-demo]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chmod 640 {[backrest-config-demo]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chown {[br-install-user]}:{[br-install-group]} {[backrest-config-demo]}</exe-cmd>
            </execute>
        </execute-list>
    </block-define>

    <block-define if="'{[package]}' ne 'none'" id="br-install">
        <execute-list host="{[br-install-host]}">
            <title>Installation de <backrest/> depuis les packets</title>

            <execute if="{[os-type-is-debian]} &amp;&amp; '{[package]}' ne 'apt'" user="root" err-suppress="y" show="n">
                <exe-cmd>dpkg -i {[pgbackrest-repo-path]}/{[package]}</exe-cmd>
                <exe-cmd-extra> 2>&amp;1</exe-cmd-extra>
            </execute>

            <execute if="{[os-type-is-debian]} &amp;&amp; '{[package]}' ne 'apt'" user="root" show="n">
                <exe-cmd>apt-get -y install -f</exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>

            <execute if="{[os-type-is-debian]} &amp;&amp; '{[package]}' ne 'apt'" user="root" skip="y">
                <exe-cmd>apt-get install pgbackrest</exe-cmd>
            </execute>

            <execute if="{[os-type-is-debian]} &amp;&amp; '{[package]}' eq 'apt'" user="root" show="n">
                <exe-cmd>apt-get update</exe-cmd>
            </execute>

            <execute if="{[os-type-is-debian]} &amp;&amp; '{[package]}' eq 'apt'" user="root" show="y">
                <exe-cmd>apt-get install pgbackrest</exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>

            <execute if="{[os-type-is-centos]} &amp;&amp; '{[package]}' ne 'yum'" user="root" show="n">
                <exe-cmd>yum -y install {[pgbackrest-repo-path]}/{[package]}</exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>

            <execute if="{[os-type-is-centos]} &amp;&amp; '{[package]}' ne 'yum'" user="root" skip="y">
                <exe-cmd>yum install pgbackrest</exe-cmd>
            </execute>

            <execute if="{[os-type-is-centos]} &amp;&amp; '{[package]}' eq 'yum'" user="root">
                <exe-cmd>yum install pgbackrest</exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>
        </execute-list>

        <execute-list if="'{[br-install-user]}' ne 'postgres'" host="{[br-install-host]}">
            <title>Mise à jours de permission sur les répertoires et fichier de configuration</title>

            <execute user="root">
                <exe-cmd>chown {[br-install-user]}:{[br-install-group]} /var/log/pgbackrest</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chown {[br-install-user]}:{[br-install-group]} {[backrest-config-demo]}</exe-cmd>
            </execute>
        </execute-list>
    </block-define>

    <block-define id="br-install-repo">
        <execute-list if="'{[package]}' eq 'none'" host="{[br-install-host]}">
            <title>Création du dépot de sauvegarde pour <backrest/></title>

            <execute user="root">
                <exe-cmd>mkdir -p {[backrest-repo-path]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chmod 750 {[backrest-repo-path]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chown {[br-install-user]}:{[br-install-group]} {[backrest-repo-path]}</exe-cmd>
            </execute>
        </execute-list>

        <execute-list if="'{[package]}' ne 'none' &amp;&amp; '{[br-install-user]}' ne 'postgres'" host="{[br-install-host]}">
            <title>Mise à jour du dépot de sauvegarde de <backrest/></title>

            <execute user="root">
                <exe-cmd>chown {[br-install-user]}:{[br-install-group]} {[backrest-repo-path]}</exe-cmd>
            </execute>
        </execute-list>
    </block-define>

    <!-- ======================================================================================================================= -->
    <block-define id="s3-setup">
        <p><backrest/> prend en charge l'emplacement du dépot de sauvegarde dans le magasin d'objet  <proper>compatible-S3</proper>.  Le conteneur utilisé pour stocker le dépôt doit être crée à l'avance &amp;mdash; <backrest/> il ne se créera donc pas automatiquement.  Le dépôt peut être situé à la racine du conteneur (<path>/</path>) mais il est préférable de le pacer dans un sous-chemin afin d'éviter des conflit lors du sockage des traces ou d'autres donnée.</p>

        <backrest-config host="{[s3-setup-host]}" file="{[backrest-config-demo]}" owner="{[s3-setup-config-owner]}">
            <title>Configuration de <proper>S3</proper></title>

            <backrest-config-option section="global" key="repo1-type">s3</backrest-config-option>
            <backrest-config-option section="global" key="repo1-path">/{[s3-repo]}</backrest-config-option>
            <backrest-config-option section="global" key="repo1-s3-key">{[s3-key]}</backrest-config-option>
            <backrest-config-option section="global" key="repo1-s3-key-secret">{[s3-key-secret]}</backrest-config-option>
            <backrest-config-option section="global" key="repo1-s3-bucket">{[s3-bucket]}</backrest-config-option>
            <backrest-config-option section="global" key="repo1-s3-endpoint">{[s3-endpoint]}</backrest-config-option>
            <backrest-config-option section="global" key="repo1-s3-region">{[s3-region]}</backrest-config-option>

            <backrest-config-option section="global" key="process-max">4</backrest-config-option>
        </backrest-config>

        <execute-list if="'{[s3-local]}' eq 'y'" host="{[s3-setup-host]}" show="n">
            <title>Create the bucket</title>

            <!-- Set host entries to redirect AWS to local s3 server -->
            <execute user="root" user-force="y" show="n">
                <exe-cmd>echo "{[host-s3-ip]} {[s3-bucket]}.{[s3-endpoint]} {[s3-endpoint]}" | tee -a /etc/hosts</exe-cmd>
            </execute>

            <execute user="{[s3-setup-user]}" if="'{[s3-setup-create-bucket]}' eq 'y'" show='n'>
                <exe-cmd>{[project-exe]} repo-create</exe-cmd>
            </execute>
        </execute-list>

        <admonition type="note">La region et le <quote>endpoint</quote> devront être configurés en fonction de l'endroit où se trouve le conteneur. Les valeurs données ici sont pour la région <id>{[s3-region]}</id>.</admonition>
    </block-define>

    <!-- SECTION => INTRODUCTION -->
    <section id="introduction">
        <title>Introduction</title>

        <!-- Create S3 server first to allow it time to boot before being used -->
        <host-add if="'{[s3-local]}' eq 'y'" id="{[host-s3-id]}" name="{[host-s3]}" user="root" image="minio/minio:RELEASE.2020-05-06T23-23-25Z" os="{[os-type]}" option="-v {[fake-cert-path]}/s3-server.crt:/root/.minio/certs/public.crt:ro -v {[fake-cert-path]}/s3-server.key:/root/.minio/certs/private.key:ro -e MINIO_REGION={[s3-region]} -e MINIO_DOMAIN={[s3-endpoint]} -e MINIO_BROWSER=off -e MINIO_ACCESS_KEY={[s3-key]} -e MINIO_SECRET_KEY={[s3-key-secret]}" param="server /data --address :443" update-hosts="n"/>

        <p>Ce guide d'utilisateur est destiné à être suivi séquentiellement du début à la fin&amp;mdash; chaque section dépend de la précédente. Par exemple, la section <link section="/backup">Backup</link> repose sur la configuration qui est décrite dans la sesction <link section="/quickstart">Démarrage rapide</link>.  Une fois que la configuration de <backrest/> est opérationnelle, il est possible de sauter des étapes, mais il est recomandé de suivre le guide dans l'ordre la première fois.</p>

        <p>Bien que les exemples soient destinées pour être mise en oeuvre avec le système d'exploitation  {[user-guide-os]} et <postgres/> version {[pg-version]}, il devrait être assez simple d'appliquer ce guide à toute autre distribution Unix et à toutes les versions de <postgres/>. Seules les commandes spécifiques au système d'exploitation sont celle qui permettent de créer, de démarrer, d'arrêter et de détruire une instance <postgres/>.  Les commandes de <backrest/> seront les mêmes quelques soit le syst-me Unix que vous utilisez&amp;mdash; bien entendue les emplacement d'installation des excutables peuvent varier.

        Les informations et la documentation relatives à la configuration d'une instance <postgres/> se trouvent sur les sites <link url='http://www.postgresql.org/docs/{[pg-version]}/static/index.html'>Manuel en Anglais officiel</link> ou pour la version française <link url='http://www.postgresqlfr.org/docs/{[pg-version]}/static/index.html'>sur le site d'association PostgreSQLfr</link>.</p>

        <p>Le présent guide de l'utilisateur adopte une approche assez nouvelle dans la rédaction de la documentation. En effet chaque comande est exécutée sur une machine virtuelle lorsque la documentation est rédigé de façon automatique à partir de la source au format XML. Cela signifie que vous pouvez avoir la certitude que les commandes fonctionnent correctement dans l'ordre qui vous sera présenté. Les résultats de chaque commande sont capturés et affichés sous celle-ci. Si la sortie n'est pas incluse, c'est qu'elle a été jugée non pertinente.</p>

        <p>Toutes les commandes sont destinées à être exécutées par un utilisateur non privilégié qui dispose du droit sudo pour les utilisateurs <user>root</user> et <user>postgres</user>. Il est possible d'exécuter les commandes directement en tant que l'utilisateurs <user>root</user> et <user>postgres</user>&amp;mdash; dans ce cas, les commandes <cmd>sudo</cmd> peuvent être retirées.</p>
    </section>

    <!-- SECTION => CONCEPTS -->
    <section id="concept">
        <title>Concepts</title>

        <p>La notion des concepts suivants sont définis comme étant pertients dans la compréhention de  <backrest/>, <postgres/>, et de ce guide de l'utilisateur.</p>

        <!-- SECTION => CONCEPTS - BACKUP -->
        <section id="backup">
            <title>Sauvegarde</title>

            <p>Une sauvegarde est une copie cohérente d'une instance de base de données qui peut être restauré suite à une panne matérielle, pour effectuer une récupération à un instant (PITR) ou encore pour créer une nouvelle instance esclave.</p>

            <p><b>Sauvegarde complète</b>: <backrest/> copie l'intégralité du contenu de l'instance de base de données sur la sauvegarde. La première sauvegarde d'une instance est toujours une sauvegarde complète. <backrest/> sera toujours capable de restaurer directement une sauvegarde complète. Cette sauvegarde complète ne dépent d'aucun autre fichier en dehors de la sauvegarde complète, ceci pour des raisons de consistance.</p>

            <p><b>Sauvegarde différentielle</b>: <backrest/> ne copie que les fichiers de l'instance ayant changé depuis la dernière sauvegarde complète. Lors d'une restauration dfférentielle <backrest/> restaure en copiant tous les fichiers de la sauvegarde différentielle ainsi que les fichiers inchangé de la précédente sauvegarde complète. L'avantage d'une sauvegarde différentielle est qu'elle nécessite moins d'espace disque qu'une sauvegarde complète. Cependant, la sauvegarde différentielle et la sauvegarde complète doivent toutes deux être valides pour restaurer la sauvegarde différentielle.</p>

            <p><b>Sauvegarde incrémentale</b>: <backrest/> ne copie que les fichiers de l'instance de base de données qui ont été modifiés depuis la dernière sauvegarde (celle-ci peut être une autre sauvegarde incrémentale, une sauvegarde différentielle ou une sauvegarde complète). Puisqu'une sauvegarde incrémentale n'inclut que les fichiers modifiés depuis la sauvegarde précédente, ils sont généralement beaucoup plus petits que les sauvegardes complètes ou différentielles. Comme pour la sauvegarde différentielle, la sauvegarde incrémentale dépend des autres sauvegardes pour pouvoir être restaurer. Etant donné que la sauvegarde incrémentale ne comprend que les fichiers modifiés depuis la dernière sauvegarde, toutes les sauvegardes incrémentale antérieures qui ont été effectuées ainsi que la sauvegarde différentielle antérieure et la sauvegarde complète antérieure doivent toutes être valides pour pouvoir effectuer une restauration de la sauvegarde incrémentale. Si aucune sauvegarde différentielle n'existe, alors toutes les sauvegardes incrémentales antérieures doivent être valide depuis la dernière sauvegarde complète pour pouvoir restaurer la sauvegarde incrémentale.</p>
        </section>

        <!-- SECTION => CONCEPTS - RESTORE -->
        <section id="restore">
            <title>Restoration</title>

            <p>Une restauration est une opération qui consiste à copier une sauvegarde sur un système pour être lancer en temps qu'instance de base de données. Une restauration nécessite les fichiers de sauvegarde et un ou plusieurs segments WAL (journaux de transaction) afin de fonctionner correctement.</p>
        </section>

        <!-- SECTION => CONCEPTS - WAL -->
        <section id="wal">
            <title>Journaux de transaction (Write Ahead Log : WAL)</title>

            <p>Le WAL est le mécanisme que <postgres/> utilise pour s'assurer qu'aucun changement confirmé n'est perdu. Les transactions sont écrites séquentiellement dans le WAL et une transaction est considérée comme confirmée lorsque ces écritures sont enregistrées sur le disque.  Ensuite, un processus en arrière-plan écrit les modifications dans les fichiers principaux de l'instance de la base de données (également connu sous le nom <quote>heap</quote>). En cas de crash, le WAL est rejoué pour rendre la base de données cohérente.</p>

            <p>Le WAL est conceptuellement infini mais en pratique, il est divisé en fichiers individuels de 16 Mo appelés segments. Les segments WAL suivent la convention de nommage suivant  <id>0000000100000A1E000000FE</id> où les 8 premiers chiffres hexadécimaux représentent la 'timeline' et les 16 chiffres suivants sont le numéro de séquence logique (LSN).</p>

        </section>

        <!-- SECTION => CONCEPTS - ENCRYPTION -->
        <section id="encryption">
            <title>Chiffrement</title>

            <p>Le chiffrement est le processus de conversion des données dans un format qui n'est pas reconnaissable à moins que le mot de passe approprié (également appelé clef) ne soit fourni.</p>

            <p><backrest/> chiffrera le dépôt de sauvegarde sur la base d'un mot de passe fourni par l'utilisateur, empêchant ainsi tout accès non autorisé aux données stockées dans le dépôt.</p>
        </section>
    </section>

    <!-- SECTION => UPGRADING -->
    <section id="upgrading">
        <title>Mise à niveau de {[project]}</title>

        <section id="v1-v2">
            <title>Mise à niveau de {[project]} depuis la v1 vers la v2</title>

            <p>Le passage de la version <proper>v1</proper> vers la version <proper>v2</proper> est assez simple. Le format du dépôt de sauvegarde n'a pas changé et les options marqué comme dépréciées de la <proper>v1</proper> reste acceptées de sorte que pour la plupart des installations, une simple mise à jours des binaires vers la nouvelle version suffit.</p>

            <p>Toutefois, il y a quelques mises en garde :</p>

            <list>
                <list-item>L'option dépréciées <br-option>thread-max</br-option> n'est plus valide. Utiliser  <br-option>process-max</br-option> à la place.</list-item>

                <list-item>L'option dépréciées <br-option>archive-max-mb</br-option> n'est plus valide. Cette option a été remplacée par l'option <br-option>archive-push-queue-max</br-option> qui a une syntaxe différente.</list-item>

                <list-item>La valeur par defaut pour l'option <br-option>backup-user</br-option> est passée de <id>backrest</id> à <id>pgbackrest</id>.</list-item>

                <list-item>Dans la version <proper>v2.02</proper> l'emplacement par défaut du fichier de configuration de <backrest/> a changé de <file>/etc/pgbackrest.conf</file> à <file>/etc/pgbackrest/pgbackrest.conf</file>. Si le fichier <file>/etc/pgbackrest/pgbackrest.conf</file> n'existe pas alors le fichier <file>/etc/pgbackrest.conf</file> sera chargé à la place, s'il existe.</list-item>
            </list>

            <p>De nombreux noms d'options ont été modifiés pour améliorer la cohérence, bien que les anciens noms de la version <proper>v1</proper> soient toujours acceptés. De manière générale, les options <id>db-*</id> ont été renommées en <id>pg-*</id> et les options <id>backup-*</id>/<id>retention-*</id> ont été renommées en <id>repo-*</id> lorsque que celà été approprié.</p>

            <p>Les options de <postgres/> et du dépot de sauvegarde doivent être référencées lors de l'utilisation des nouveaux noms introduit par la version <proper>v2</proper>, (par exemple pour les options <br-option>pg1-host</br-option>, <br-option>pg1-path</br-option>, <br-option>repo1-path</br-option>, <br-option>repo1-type</br-option>, etc.). Un seul dépôt est autorisé actuellement mais une plus grande flexibilité est prévue pour la version <proper>v2</proper>.</p>
        </section>
    </section>

    <!-- ======================================================================================================================= -->
    <section if="'{[package]}' eq 'none'" id="build">
        <title>Construction</title>

        <p if="{[os-type-is-debian]}">Les paquets pour les distributions {[user-guide-os]} de <backrest/> sont disponible sur <link url="https://www.postgresql.org/download/linux/ubuntu/">apt.postgresql.org</link>.  S'ils ne sont pas fournis pour votre distribution/version, il est facile de télécharger les sources et de l'installer manuellement</p>

        <p if="{[os-type-is-centos]}">{[user-guide-os]} packages for <backrest/> are available from <link url="{[crunchy-url-base]}">Crunchy Data</link> or <link url="http://yum.postgresql.org">yum.postgresql.org</link>, but it is also easy to download the source and install manually.</p>

        <host-add id="{[host-build-id]}" name="{[host-build]}" user="{[host-build-user]}" image="{[host-build-image]}" os="{[os-type]}" mount="{[host-build-mount]}" option="{[host-option]}"/>

        <p>Lorsque l'on construit à partir des sources, il est préférable d'utiliser un système dédié à la construction plutôt que de le faire sur votre environnement de production.  La plupart des outils nécessaires à la construction ne doivent généralement pas être installés sur un environnement de production. <backrest/> est composé d'un seul exécutable, il est donc facile de le copier vers votre enironnement de produition une fois construit.</p>

        <execute-list host="{[host-build]}">
            <title>Télécharger la version <id>{[version]}</id> de <backrest/> et extraire dans le répertoire de construction <path>/build</path></title>

            <!-- This is shown to the user but never actually run for the very good reason that the release is not available before the documentation is built -->
            <execute skip="y">
                <exe-cmd>wget -q -O -
                    {[github-url-release]}/{[version]}.tar.gz |
                    tar zx -C /build</exe-cmd>
            </execute>

            <!-- These commands simulate what the command above would do if it could be run -->
            <execute user="root" show="n">
                <exe-cmd>mkdir -p /build/pgbackrest-release-{[version]}</exe-cmd>
            </execute>
            <execute user="root" show="n">
                <exe-cmd>cp -r {[pgbackrest-repo-path]}/src /build/pgbackrest-release-{[version]}</exe-cmd>
            </execute>
            <execute user="root" show="n">
                <exe-cmd>chown -R {[host-build-user]} /build/pgbackrest-release-{[version]}</exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[host-build]}">
            <title>Installation et construction les dépendances</title>

            <execute if="{[os-type-is-debian]}" user="root" show="n" pre="y">
                <exe-cmd>apt-get update</exe-cmd>
            </execute>

            <execute if="{[os-type-is-debian]}" user="root" pre="y">
                <exe-cmd>
                  apt-get install make gcc libpq-dev libssl-dev libxml2-dev pkg-config
                  liblz4-dev libzstd-dev libbz2-dev libz-dev
                </exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>

            <execute if="{[os-type-is-centos]}" user="root" pre="y">
                <exe-cmd>
                  yum install make gcc postgresql-devel openssl-devel libxml2-devel
                  lz4-devel libzstd-devel bzip2-devel
                </exe-cmd>
                <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
            </execute>
        </execute-list>

        <execute-list host="{[host-build]}">
            <title>Configuration et compilation de <backrest/></title>

            <execute>
                <exe-cmd>cd /build/pgbackrest-release-{[version]}/src &amp;&amp; ./configure &amp;&amp; make</exe-cmd>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => INSTALLATION -->
    <section id="installation">
        <title>Installation</title>

        <p>Un nouvel hôte nommé <host>pg1</host> est créé pour contenir l'instance de démonstration afin d'executer les exemples de <backrest/>.</p>

        <host-add id="{[host-pg1-id]}" name="{[host-pg1]}" user="{[host-pg1-user]}" image="{[host-pg1-image]}" os="{[os-type]}" mount="{[host-pg1-mount]}" option="{[host-option]}"/>

        <!-- <execute-list if="{[pg-version]} >= 11" host="{[host-pg1]}">
            <title>Create <user>{[br-user]}</user> user</title>

            <execute if="{[os-type-is-debian]}" user="root">
                <exe-cmd>adduser {[dash]}-ingroup {[pg-group]} {[dash]}-disabled-password {[dash]}-gecos "" {[br-user]}</exe-cmd>
            </execute>
            <execute if="{[os-type-is-centos]}" user="root">
                <exe-cmd>adduser -g{[pg-group]} -n {[br-user]}</exe-cmd>
            </execute>
        </execute-list> -->

        <block id="br-install">
            <block-variable-replace key="br-install-host">{[host-pg1]}</block-variable-replace>
            <block-variable-replace key="br-install-user">postgres</block-variable-replace>
            <block-variable-replace key="br-install-group">postgres</block-variable-replace>
        </block>

        <p><backrest/> devrait maintenant être correctement installé, mais il est préférable de le vérifier. Si des dépendances ont été omises, vous obtiendrez une erreur lorsque vous lancerez <backrest/> à partir de la ligne de commande.</p>

        <execute-list host="{[host-pg1]}">
            <title>S'assurer que l'installation a fonctionné</title>

            <execute user="postgres" output="y" filter="n">
                <exe-cmd>{[project-exe]}</exe-cmd>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => QUICKSTART -->
    <section id="quickstart">
        <title>Démarrage rapide</title>

        <p>La section Démarrage rapide couvre la configuration de base de <backrest/> et <postgres/>. Elle présente les commandes <cmd>backup</cmd>, <cmd>restore</cmd>, et <cmd>info</cmd>.</p>

        <!-- SECTION => QUICKSTART - SETUP DEMO CLUSTER -->
        <section id="setup-demo-cluster">
            <title>Mise en place de l'instance de démonstration</title>

            <p>La création de l'instance de démonstration est facultative mais fortement recommandée, en particulier pour les nouveaux utilisateurs. Les exemples de commande de ce guide font référence à cette instance de démonstration; les exemples sont fonctionnel sur une instance fonctionnant sur le port d'écoute par defaut (c'est-à-dire le port 5432). L'instance ne sera pas encore lancé, car il reste des actions de configuration à réaliser qui seront décrites dans la section suivante.</p>

            <execute-list host="{[host-pg1]}">
                <title>Création de l'instance de démonstation</title>

                <execute user="postgres">
                    <exe-cmd>
                        {[pg-bin-path]}/initdb
                            -D {[pg-path]} -k -A peer</exe-cmd>
                </execute>

                <execute if="{[os-type-is-debian]}" user="root" output="y" filter="n">
                    <exe-cmd>{[pg-cluster-create]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Par défaut, <postgres/> n'accepte que les connexions locales.  Les exemples présentés dans ce guide nécessiteront des connexions à partir d'autres serveurs ce qui implique de modifier le paramètre <pg-option>listen_addresses</pg-option> pour écouter sur toutes les interfaces. Ceci n'est peut être pas approprié pour les installations sécurisées.</p>

            <postgres-config host="{[host-pg1]}" file="{[postgres-config-demo]}">
                <title>Modification <pg-option>listen_addresses</pg-option></title>

                <postgres-config-option key="listen_addresses">'*'</postgres-config-option>
            </postgres-config>

            <p>À des fins de démonstration, le paramètre <pg-option>log_line_prefix</pg-option> sera configuré au minimum. Cela permet de garder la sortie du journal aussi brève que possible pour mieux illustrer les informations importantes.</p>

            <postgres-config host="{[host-pg1]}" file="{[postgres-config-demo]}">
                <title>Modification de <pg-option>log_line_prefix</pg-option></title>

                <postgres-config-option key="log_line_prefix">''</postgres-config-option>
            </postgres-config>

            <p if="{[os-type-is-centos]}">Par défaut sur {[user-guide-os]} le nom du fichier de journalisation des traces inclus le nom du jour de la semaine. Cela rend l'automatisation du guide de l'utilisateur un peu plus compliquée, le paramètre <pg-option>log_filename</pg-option> est donc fixée à une constante.</p>

            <postgres-config host="{[host-pg1]}" if="{[os-type-is-centos]}" file="{[postgres-config-demo]}">
                <title>Modification <pg-option>log_filename</pg-option></title>

                <postgres-config-option key="log_filename">'postgresql.log'</postgres-config-option>
            </postgres-config>
        </section>

        <!-- SECTION => QUICKSTART - CONFIGURE STANZA -->
        <section id="configure-stanza">
            <title>Configuration du dépots de sauvegarde (Stanza)</title>

            <option-description key="stanza"/>

            <p>Le nom 'demo' décrit assez bien l'objectif du dépot de données de sauvegarde (stanza). Ce qui en fera également un bon nom pour notre 'stanza'.</p>

            <p><backrest/>doit savoir où se trouve le répertoire des données de base de l'instance <postgres/>.  Le chemin peut être directement obtenu auprès de <postgres/> mais dans un scénario de restauration, le processus <postgres/> ne sera pas disponible.  Lors des sauvegardes, la valeur fournie à  <backrest/> sera comparée au chemin sur lequel <postgres/> est exécuté; ils doivent être égaux sinon la sauvegarde retournera une erreur.  Assurez-vous que le parmaètre <br-option>pg-path</br-option> soit strictement égal au parmaètre <pg-option>data_directory</pg-option> du fichier  <file>postgresql.conf</file>.</p>

            <p>Par défaut sur {[user-guide-os]} le répertoire de l'instance est <path>{[pg-path-default]}</path> afin de déterminer facilement le chemin correct du repertoire de données.</p>

            <p>Lors de la création du fichier <file>{[backrest-config-demo]}</file> le propriétaire de la base de données (généralement <id>postgres</id>) doit se voir accorder les privilèges de lecture.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration du réprtoire de donnée de <postgres/></title>

                <backrest-config-option section="demo" key="pg1-path">{[pg-path]}</backrest-config-option>

                <backrest-config-option section="global" key="log-level-stderr">off</backrest-config-option>
                <backrest-config-option section="global" key="log-timestamp">n</backrest-config-option>
            </backrest-config>

            <p>Led fichiers de configuration de <backrest/> suivent la convention Windows INI. Les sections sont indiquées par du texte entre parenthèses et des paires clé/valeur sont contenues dans chaque section.  Les lignes commençant par <id>#</id> sont ignorées et peuvent être utilisées comme commentaires.</p>

            <p>Les fichiers de configuration de <backrest/> peuvent être chargés de plusieurs façons :</p>
            <list>
                <list-item><br-option>config</br-option> et <br-option>config-include-path</br-option> sont par défaut : le fichier de configuration par défaut sera chargé, s'il existe, et les fichiers  <file>*.conf</file> dans le chemin d'inclusion de la configuration par défaut seront ajoutés, s'ils existent.</list-item>
                <list-item>Lorsque l'option <br-option>config</br-option> est spécifiée : seul le fichier de configuration spécifié sera chargé et il devra exister.</list-item>
                <list-item>Lorsque l'option <br-option>config-include-path</br-option> est spécifiée :  Les fichiers <file>*.conf</file> dans le chemin d'inclusion de la configuration seront chargés et le chemin doit exister. Le fichier de configuration par défaut sera chargé s'il existe. Dans le cas où vous souhaitez ne charge que les fichiers du chemin d'inclusion alors l'option <br-option>--no-config</br-option> peut être ajoutée.</list-item>
                <list-item>Lorsque l'option <br-option>config</br-option> est <br-option>config-include-path</br-option> sont spécifiées en utilisant les valeurs spécifiées par l'utilisateur, le fichier de configuration sera chargé et les fichiers <file>*.conf</file> du chemin d'inclusion de la configuration seront ajoutés. Les. Les fichiers doivent exister.</list-item>
                <list-item>Lorsque l'option <br-option>config-path</br-option> est spécifié : ce paramètre remplacera le chemin de base pour l'emplacement par défaut du fichier de configuration et/ou le chemin de base du paramètre <br-option>config-include-path</br-option> par défaut, à moins que l'option <br-option>config</br-option> et/ou <br-option>config-include-path</br-option> ne soit explicitement définie.</list-item>
            </list>

            <p>Les fichiers sont concaténés comme s'il s'agissait d'un seul gros fichier ; 'ordre n'a pas d'importance, mais il y a une règle de classement basée sur les sections. is precedence based on sections. Ce classement est le suivant (du plus haut vers le plus bas) :</p>

            <list>
                <list-item>[<i>stanza</i>:<i>command</i>]</list-item>
                <list-item>[<i>stanza</i>]</list-item>
                <list-item>[global:<i>command</i>]</list-item>
                <list-item>[global]</list-item>
            </list>

            <admonition type="note">Les paramètres <br-option>--config</br-option>, <br-option>--config-include-path</br-option> et <br-option>--config-path</br-option> ne sont disponible qu'à partir de la ligne de commande.</admonition>

            <p><backrest/>  peut également être configuré à l'aide de variables d'environnement comme décrit dans le document <link url="command.html">référentiel de commandes</link>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Configuration de <br-option>log-path</br-option> en utilisant les variables d'environnement</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>bash -c '
                        export PGBACKREST_LOG_PATH=/path/set/by/env &amp;&amp;
                        {[project-exe]} --log-level-console=error help backup log-path'</exe-cmd>
                    <exe-highlight>current\: \/path\/set\/by\/env</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => QUICKSTART - CREATE REPOSITORY -->
        <section id="create-repository">
            <title>Création du dépot de sauvegarde</title>

            <option-description key="repo-path"/>

            <p>Pour cette démonstration, le dépôt sera stocké sur le même hôte que le serveur de l'instance <postgres/>. Cette configuration est la plus simple et est utile dans les cas où un logiciel de sauvegarde traditionnel est utilisé pour sauvegarder l'hôte de la base de données.</p>

            <block id="br-install-repo">
                <block-variable-replace key="br-install-host">{[host-pg1]}</block-variable-replace>
                <block-variable-replace key="br-install-user">postgres</block-variable-replace>
                <block-variable-replace key="br-install-group">postgres</block-variable-replace>
            </block>

            <p>Le chemin du dépôt doit être configuré de telle sorte pour que <backrest/> sache où le trouver. </p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration de répertoire du dépots de sauvegarde de <backrest/></title>

                <backrest-config-option section="global" key="repo1-path">{[backrest-repo-path]}</backrest-config-option>
            </backrest-config>
        </section>

        <!-- =================================================================================================================== -->
        <section id="s3-support" if="'{[s3-all]}' eq 'y'">
            <title>Support des magasins d'objets compatibles S3</title>

            <block id="s3-setup">
                <block-variable-replace key="s3-setup-host">{[host-pg1]}</block-variable-replace>
                <block-variable-replace key="s3-setup-user">postgres</block-variable-replace>
                <block-variable-replace key="s3-setup-config-owner">postgres:postgres</block-variable-replace>
                <block-variable-replace key="s3-setup-create-bucket">y</block-variable-replace>
            </block>
        </section>

        <!-- SECTION => QUICKSTART - CONFIGURE ARCHIVING -->
        <section id="configure-archiving">
            <title>Configuration de l'archivage</title>

            <p>La sauvegarde d'une instance de <postgres/> requiert que l'archivage des journaux de transaction (WAL) soit activé.  Notez qu'au moins un segment de WAL sera créé pendant le processus de sauvegarde et ceux même si aucune écriture explicite n'est effectuée sur votre instance.</p>

            <postgres-config host="{[host-pg1]}" file="{[postgres-config-demo]}">
                <title>Configuration des paramètres d'archivage</title>

                <postgres-config-option key="archive_command">'{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} archive-push %p'</postgres-config-option>
                <postgres-config-option key="archive_mode">on</postgres-config-option>
                <postgres-config-option key="wal_level">{[wal-level]}</postgres-config-option>
                <postgres-config-option key="max_wal_senders">3</postgres-config-option>
            </postgres-config>

            <p>Régler le paramètre <pg-option>wal_level</pg-option> sur le niveau au minimum la valeur <pg-setting>{[wal-level]}</pg-setting> et augmenter la valeur de <pg-option>max_wal_senders</pg-option> est une bonne pratique, puisque celà vous permettra d'ajouter plus tard des esclaves sans pour autant devoir redémarrer votre instance principale.</p>

            <p>L'instance <postgres/> doit être redémarré après avoir effectué ces modifications et avant d'effectuer une sauvegarde.</p>

            <execute-list host="{[host-pg1]}">
                <title>Redémarrage de l'instance {[postgres-cluster-demo]}</title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-restart]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Lorsque l'archivage d'un segment du journal de transaction (WAL) est censé prendre plus de 60 secondes (par défaut) pour atteindre le dépôt de sauvegarde de <backrest/>, le paramètre <br-option>archive-timeout</br-option> de la configuration de <backrest/> doit être augmenté. Notez bien que ce paramètre n'est pas le même que celui présent dans la configuration de <postgres/> :  <pg-option>archive_timeout</pg-option>, qui lui permet de forcer le changement d'un segment du journal de transaction (WAL) afin de forcer un archivage. Ceci est utile sur les bases de données ayant de longue périodes d'inactivité en écriture. Pour plus d'information concernant l'option <pg-option>archive_timeout</pg-option> de <postgres/> , consultez la documentation  <postgres/> <link url="https://docs.postgresql.fr/current/runtime-config-wal.html">Write Ahead Log</link>.</p>

            <p>La commande <cmd>archive-push</cmd> peut être configurée avec ses propres options.  Par exemple, un niveau de compression inférieur peut être défini pour accélérer l'archivage des WAL sans affecter la compression utilisée pour les sauvegardes.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration de <cmd>archive-push</cmd> afin d'utiliser un niveau de compression inférieur</title>

                <backrest-config-option section="global:archive-push" key="compress-level">3</backrest-config-option>
            </backrest-config>

            <p>Cette technique de configuration peut être utilisée pour n'importe quelle commande et peut même cibler un 'stanza' spécifique, exemple : <code>demo:archive-push</code>.</p>
        </section>

        <!-- SECTION => QUICKSTART - RETENTION -->
        <section id="retention">
            <title>Configuration de la retention</title>

            <p>L'expiration des sauvagarde <backrest/> se base sur les options de rétention.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configurer la rétention à 2 sauvegardes complètes</title>

                <backrest-config-option section="global" key="repo1-retention-full">2</backrest-config-option>
            </backrest-config>

            <p>Pour plus d'informations sur la rétention, voir la section sur la <link section="/retention">Retention</link>.</p>
        </section>

        <!-- SECTION => QUICKSTART - CONFIGURE ENCRYPTION -->
        <!-- Since S3 and repository host require configure-archiving, this section must come after. -->
        <section if="'{[encrypt]}' eq 'y'" id="configure-encryption">
            <title>Configuration du chiffrement du dépôt de sauvegarde</title>

            <p>Le dépôt de sauvegarde sera configuré avec un type de chiffrement (cipher) et une clé. Le chiffrement est toujours effectué côté client même si le type de dépôt (par exemple <proper>S3</proper> ou autre magasin d'objets) prend en charge le chiffrement.</p>

            <p>Il est important d'utiliser une phrase de chiffrement longue et aléatoire pour la clé de chiffrement.  Une bonne façon d'en générer une est d'exécuter la commande : <code>openssl rand -base64 48</code>.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration du dépot de sauvegarde chiffré <backrest/></title>

                <backrest-config-option section="global" key="repo1-cipher-type">{[backrest-repo-cipher-type]}</backrest-config-option>
                <backrest-config-option section="global" key="repo1-cipher-pass">{[backrest-repo-cipher-pass]}</backrest-config-option>
            </backrest-config>

            <p>Une fois que le dépôt de sauvegarde a été configuré et que celui-ci a été créée et vérifiée, les paramètres de chiffrement du dépôt ne peuvent plus être modifiés.</p>
        </section>

        <!-- SECTION => QUICKSTART - STANZA CREATE -->
        <section id="create-stanza">
            <title>Création du dépot de sauvegarde (Stanza)</title>

            <p>La commande <cmd>stanza-create</cmd> doit être exécutée sur l'hôte où se trouve le dépôt pour initialiser le dépot de sauvegarde. Il est recommandé d'exécuter la commande <cmd>check</cmd> après avoir exécuté <cmd>stanza-create</cmd> pour s'assurer que l'archivage et les sauvegardes sont correctement configurés.</p>

            <execute-list host="{[host-pg1]}">
                <title>Création du dépot de sauvegarde et configuration</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info stanza-create</exe-cmd>
                    <exe-highlight>completed successfully</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => QUICKSTART - CHECK CONFIGURATION -->
        <section id="check-configuration">
            <title>Vérification de la configuration</title>
            <cmd-description key="check"/>

            <execute-list host="{[host-pg1]}">
                <title>Vérification de la configuration</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info check</exe-cmd>
                    <exe-highlight> successfully archived to </exe-highlight>
                </execute>
            </execute-list>

            <!-- Decided not to show the error in this part of the user guide but added as a debug statement for reference. -->
            <execute-list if="'{[debug]}' eq 'y'" host="{[host-pg1]}">
                <title>Exemple d'une configuration non conforme</title>

                <execute user="postgres" output="y" err-expect="82">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --archive-timeout=0 check</exe-cmd>
                    <exe-highlight>could not find WAL segment|did not reach the archive</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => QUICKSTART - PERFORM BACKUP -->
        <section id="perform-backup">
            <title>Effectuer une sauvegarde</title>

            <p>Pour effectuer une sauvegarde de l'instance <postgres/>, lancez <backrest/> avec la commande <cmd>backup</cmd>.</p>

            <execute-list host="{[host-pg1]}">
                <title>sauvegarde de l'instance {[postgres-cluster-demo]}</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]}
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>no prior backup exists|full backup size</exe-highlight>
                </execute>

                <execute user="postgres" show="n" variable-key="backup-full-first">
                    <exe-cmd>{[cmd-backup-last]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Par défaut, <backrest/> tentera d'effectuer une sauvegarde incrémentielle.  Cependant, une sauvegarde incrémentielle doit être basée sur une sauvegarde complète et comme il n'y a pas de sauvegarde complète, <backrest/> effectue une sauvegarde complète à la place.</p>

            <p>L'option <br-option>type</br-option> peut être utilisée pour spécifier une sauvegarde complète ou différentielle.</p>

            <execute-list host="{[host-pg1]}">
                <title>Sauvegarde différentielle de l'instance {[postgres-cluster-demo]}</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=diff
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>diff backup size</exe-highlight>
                </execute>
            </execute-list>

            <p>Cette fois, il n'y a pas eu d'avertissement car une sauvegarde complète existait déjà.  Alors que les sauvegardes incrémentielles peuvent être basées sur une sauvegarde complète <i> ou</i> différentielle, les sauvegardes différentielles doivent être basées sur une sauvegarde complète.  Une sauvegarde complète peut être effectuée en exécutant la commande <cmd>backup</cmd> avec <br-setting>{[dash]}-type=full</br-setting>.</p>

            <p>Vous trouverez plus d'informations sur la commande <cmd>backup</cmd> dans la section <link section="/backup">Sauvegarde</link>.</p>
        </section>

        <!-- SECTION => QUICKSTART - SCHEDULE BACKUP -->
        <section id="schedule-backup">
            <title>Planifier une sauvegarde</title>

            <p>Des sauvegardes peuvent être programmées avec des utilitaires tels que cron.</p>

            <p>Dans l'exemple suivant, deux tâches 'cron' sont configurés pour fonctionner; les sauvegardes complètes sont programmées à 6h30 tous les dimanches, les sauvegardes différentielles à 6h30 du lundi au samedi. Si cette crontab est installée pour la première fois en milieu de semaine, alors <backrest/> exécutera une sauvegarde complète la première fois que le job différentiel est exécuté, suivi le lendemain par une sauvegarde différentielle.</p>

            <code-block title="crontab">
                #m h   dom mon dow   command
                30 06  *   *   0     pgbackrest --type=full --stanza=demo backup
                30 06  *   *   1-6   pgbackrest --type=diff --stanza=demo backup
            </code-block>

            <p>Une fois que les sauvegardes sont programmées, il est important de configurer la conservation de manière à ce que les sauvegardes expirent selon un calendrier définit, voir la section <link section="/retention">Retention</link>.</p>
        </section>

        <!-- SECTION => QUICKSTART - BACKUP INFO -->
        <section id="backup-info" depend="perform-backup">
            <title>Informations sur les sauvegardes</title>

            <p>Utilisez la commande <cmd>info</cmd> pour obtenir des informations sur les sauvegardes.</p>

            <execute-list host="{[host-pg1]}">
                <title>Obtenir des informations pour l'instance {[postgres-cluster-demo]}</title>

                <execute user="postgres" filter="n" output="y">
                    <exe-cmd>{[project-exe]} info</exe-cmd>
                    <exe-highlight>(full|incr|diff) backup</exe-highlight>
                </execute>
            </execute-list>

            <p>Chaque dépôts de sauvegarde a une section séparée et il est possible de limiter la sortie à un seul dépôt avec l'option <br-option>--stanza</br-option>. L'indicateur <id>status</id> donne une brève information sur l'état de santé du dépôt. S'il est à <id>ok</id>, alors le <backrest/> fonctionne normalement.  La ligne <id>wal min/max</id> indique les valeurs minimales et maximales des journaux de transaction (WAL) actuellement stockées dans le dépôt de sauvegarde.  Notez qu'il peut y avoir des trous en raison des politiques de conservation des archives ou pour d'autres raisons.</p>

            <p> Le message '<id>backup/expire running</id>' apparaîtra à côté de l'information '<id>status</id>' si l'une de ces commandes est en cours d'exécution sur l'hôte.</p>

            <p>Les sauvegardes sont affichées du plus ancien au plus récent.  La sauvegarde la plus ancienne sera <i>toujours</i> une sauvegarde complète (indiquée par un <id>F</id> à la fin de l'étiquette) mais la sauvegarde la plus récente peut être complète, différentielle (se termine par <id>D</id>), ou incrémentale (se termine par <id>I</id>).</p>

            <p>La ligne '<id>timestamp start/stop</id>' (horodatage de début/arrêt) définit la période pendant laquelle la sauvegarde s'est déroulée.  Le paramètre <id>timestamp stop</id> peut être utilisé pour déterminer quelle sauvegarde serait à utiliser lors d'une restauration PITR.  Vous trouverez plus d'informations sur la restauration PITR dans la section <link section="/pitr">Récupération au point d'origine (PITR)</link>.</p>

            <p>La ligne <id>wal start/stop</id> définit la plage de WAL qui est nécessaire pour rendre la base de données cohérente lors de la restauration.  La commande <cmd>backup</cmd> s'assure que cette plage de WAL se trouve bien dans le dépôt de sauvegarde avant de se terminer.</p>

            <p>L'information '<id>database size</id>' (taille de la base de données)  correspond à la taille totale non compressée de la base de données, tandis que l'information '<id>backup size</id>' (taille de la sauvegarde) correspond à la quantité de données effectivement sauvegardées (ces informations seront les mêmes pour les sauvegardes complètes).  L'information <id>repository size</id> inclut tous les fichiers de cette sauvegarde et toutes les sauvegardes référencées qui sont nécessaires pour restaurer la base de données, tandis que l'information <id>repository backup size</id> (taille du dépôt de sauvegarde) n'inclut que les fichiers de cette sauvegarde (ces informations seront également les mêmes pour les sauvegardes complètes).  La taille des dépôts reflète la taille des fichiers compressés si la compression est activée dans <backrest/> ou dans le système de fichiers.</p>

            <p>La ligne <id>backup reference list</id> (liste de référence des sauvegardes) contient les sauvegardes supplémentaires qui sont nécessaires pour restaurer cette sauvegarde.</p>
        </section>

        <!-- SECTION => QUICKSTART - PERFORM RESTORE -->
        <section id="perform-restore" depend="perform-backup">
            <title>Restauration d'une sauvegarde</title>

            <p>Les sauvegardes peuvent vous protéger contre de nombre de scénarios catastrophe, dont les plus courants sont une pannes matérielles et une corruption des données. La façon la plus simple de simuler une corruption de données est de supprimer un fichier important de l'instance <postgres/>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Arrêt de l'instance {[postgres-cluster-demo]} et suppression du fichier <file>pg_control</file></title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>rm {[pg-path]}/global/pg_control</exe-cmd>
                </execute>
            </execute-list>

            <p>Le démarrage de l'instance <postgres/> sans ce fichier entraînera une erreur.</p>

            <execute-list host="{[host-pg1]}">
                <title>Tentative de démarrage de l'instance {[postgres-cluster-demo]} corrompue</title>

                <execute if="{[os-type-is-debian]}" user="root" output="y" err-expect="1">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                    <exe-highlight>could not find the database system</exe-highlight>
                </execute>

                <execute if="{[os-type-is-centos6]}" user="root" show="n">
                    <exe-cmd>rm -f {[postgres-log-pgstartup-demo]}</exe-cmd>
                </execute>

                <execute if="{[os-type-is-centos]}" user="root" err-expect="1">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute if="{[os-type-is-centos6]}" user="root" output="y">
                    <exe-cmd>cat {[postgres-log-pgstartup-demo]}</exe-cmd>
                    <exe-highlight-type>error</exe-highlight-type>
                    <exe-highlight>could not find the database system</exe-highlight>
                </execute>

                <execute if="{[os-type-is-centos7]}" user="root" output="y" err-expect="3">
                    <exe-cmd>{[pg-cluster-check]}</exe-cmd>
                    <exe-highlight>Failed to start PostgreSQL</exe-highlight>
                </execute>
            </execute-list>

            <p>Pour restaurer une sauvegarde de l'instance <postgres/>, lancez <backrest/> avec la commande <cmd>restore</cmd>. L'instance doit être arrêté (dans ce cas, elle l'est déjà ) et tous les fichiers doivent être supprimés du répertoire de données <postgres/>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Suppression des anciens fichier de l'instance {[postgres-cluster-demo]}</title>

                <execute user="postgres">
                    <exe-cmd>find {[pg-path]} -mindepth 1 -delete</exe-cmd>
                </execute>
            </execute-list>

            <execute-list host="{[host-pg1]}">
                <title>Restauration et démarrage de l'instance <postgres/> {[postgres-cluster-demo]}</title>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} restore</exe-cmd>
                </execute>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Cette fois, le cluster a démarré avec succès puisque la restauration a remplacé le fichier <file>pg_control</file>.</p>

            <p>Vous trouverez plus d'informations sur la commande <cmd>restore</cmd> dans la section <link section="/restore">Restauration</link>..</p>
        </section>
    </section>

    <!-- SECTION => BACKUP -->
    <section id="backup" depend="/quickstart/create-stanza">
        <title>Sauvegarde</title>

        <p>La section Sauvegarde introduit des fonctionnalités supplémentaires de la commande <cmd>backup</cmd>.</p>

        <!-- SECTION => BACKUP - START-FAST -->
        <section id="option-start-fast">
            <title>Option de démarrage rapide</title>

            <p>Par défaut, <backrest/> attendra le prochain point de contrôle régulier (Checkpoint) avant de commencer une sauvegarde.  En fonction des paramètres <pg-option>checkpoint_timeout</pg-option> et <pg-option>checkpoint_segments</pg-option> de <postgres/>, il peut s'écouler un certain temps avant qu'un point de contrôle soit terminé et que la sauvegarde puisse commencer.</p>

            <execute-list host="{[host-pg1]}">
                <title>Sauvegarde incrémentale de l'instance {[postgres-cluster-demo]} avec le point de contrôle régulièrement programmé</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=incr
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>backup begins after the next regular checkpoint completes</exe-highlight>
                </execute>
            </execute-list>

            <p>Lorsque <br-setting>{[dash]}-start-fast</br-setting> est transmis sur la ligne de commande ou que <br-setting>start-fast=y</br-setting> est défini dans le fichier de configuration <file>{[backrest-config-demo]}</file>, un point de contrôle (checkpoint) immédiat est demandé sur l'instance <postgres/> et la sauvegarde démarre plus rapidement. C'est utile pour les tests et les sauvegardes exceptionnelles.  Par exemple, si une sauvegarde est effectuée avant une plage de mainteance pour mise à jours, il est inutile d'attendre le prochain point de contrôle et donc il est utile de le forcer. Comme les sauvegardes planifiées ne se font généralement qu'une fois par jour, il est improbable que l'activation de <br-option>start-fast</br-option> (démarrage rapide) dans  <file>{[backrest-config-demo]}</file> affecte négativement les performances. Cependant pour les systèmes à grand volume transctionnels, vous pouvez vouloir passer <br-setting>{[dash]}-start-fast</br-setting> sur la ligne de commande à la place. Il est également possible d'ignorer le paramètre du fichier de configuration en utilisant le paramètre <br-setting>{[dash]}-no-start-fast</br-setting> de la ligne de commande.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Activation du paramètre <br-option>start-fast</br-option></title>

                <backrest-config-option section="global" key="start-fast">y</backrest-config-option>
            </backrest-config>

            <execute-list host="{[host-pg1]}">
                <title>Sauvegarde incrémentale de l'instance {[postgres-cluster-demo]} avec un point de contrôle immédiat (immediat checkpoint)</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=incr
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>backup begins after the requested immediate checkpoint completes</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => BACKUP - STOP-AUTO -->
        <section if="{[pg-version]} &lt; 9.6" id="option-stop-auto">
            <title>Option d'arrêt automatique</title>

            <p>Parfois, <backrest/> peut se terminer de manière inattendue et la sauvegarde en cours sur le cluster <postgres/> n'est pas correctement arrêtée. <backrest/> se termine aussi vite que possible lorsqu'une erreur se produit, afin que la cause puisse être indiquée avec précision et ne soit pas masquée par un autre problème qui pourrait survenir lors d'un nettoyage plus approfondi</p>

            <p>Ici, une erreur est intentionnellement causée par la suppression des autorisations sur le dépôt sauvegarde.</p>

            <execute-list host="{[host-pg1]}">
                <title>Révoquer les privilèges d'écriture dans le dépôt <backrest/> et tenter une sauvegarde</title>

                <execute user="root">
                    <exe-cmd>chmod 550 {[backrest-repo-path]}/backup/{[postgres-cluster-demo]}/</exe-cmd>
                </execute>

                <execute user="postgres" output="y" err-expect="47">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=incr
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>ERROR:</exe-highlight>
                </execute>
            </execute-list>

            <p>Même lorsque les autorisations sont corrigées, <backrest/> sera toujours incapable d'effectuer une sauvegarde parce que l'instance <postgres/>est resté en mode sauvegarde.</p>

            <execute-list host="{[host-pg1]}">
                <title>Restaurer les privilèges d'écriture sur le dépôt <backrest/> et tenter une sauvegarde</title>

                <execute user="root">
                    <exe-cmd>chmod 750 {[backrest-repo-path]}/backup/{[postgres-cluster-demo]}/</exe-cmd>
                </execute>

                <execute user="postgres" output="y" err-expect="57">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=incr
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>ERROR:</exe-highlight>
                </execute>
            </execute-list>

            <p>L'activation de l'option <br-option>stop-auto</br-option> permet à <backrest/> d'arrêter la sauvegarde en cours si elle détecte qu'aucun autre processus de sauvegarde <backrest/> n'est en cours.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Activer l'option <br-option>stop-auto</br-option></title>

                <backrest-config-option section="global" key="stop-auto">y</backrest-config-option>
            </backrest-config>

            <p>Maintenant, <backrest/> arrêtera l'ancienne sauvegarde et en commencera une nouvelle afin que le processus puisse se terminer avec succès.</p>

            <execute-list host="{[host-pg1]}">
                <title>Effectuer une sauvegarde incrémentale</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=incr
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>cluster is already in backup mode|backup begins after the requested immediate checkpoint completes</exe-highlight>
                </execute>
            </execute-list>

            <p>Bien qu'utile, cette fonction peut ne pas être appropriée lorsqu'une autre solution de sauvegarde tierce est utilisée pour effectuer des sauvegardes à chaud car <backrest/> ne reconnaît pas que l'autre logiciel est en cours d'exécution et peut mettre fin cette sauvegarde lancée par ce logiciel.  Toutefois, il serait inhabituel d'exécuter plus d'une solution de sauvegarde en même temps, de sorte que cela ne devrait pas poser de problème.</p>

            <admonition type="note"><id>pg_dump</id> et <id>pg_basebackup</id> n'effectuent pas de sauvegardes en temps réel et ne sont donc pas affectés par le problème. Il est possible de les exécuter en toute sécurité avec <backrest/>.</admonition>
        </section>

        <!-- SECTION => BACKUP - ARCHIVE-TIMEOUT -->
        <section id="option-archive-timeout">
            <title>Timeout des archives</title>

            <p>Lors d'une sauvegarde à chaud, <backrest/> attend que les segments WAL qui sont nécessaires à la cohérence de la sauvegarde soient archivés. Ce temps d'attente est régi par l'option <backrest/> <br-option>archive-timeout</br-option> dont la valeur par défaut est de 60 secondes. Si l'on sait que l'archivage d'un segment individuel prend plus de temps, cette option doit être augmentée.</p>
        </section>
    </section>

    <!-- *********************************************************************************************************************** -->
    <section id="monitor" depend="/quickstart/perform-backup">
        <title>Supervision</title>

        <p>La supervision est un élément important de tout système de production.  De nombreux outils sont disponibles et il est possible de contrôler n'importe lequel d'entre eux avec un peu de travail.</p>

        <p><backrest/> peut produire des informations sur le dépôt au format JSON qui comprend une liste de toutes les sauvegardes pour chaque dépots de sauvegardes et des informations sur les archives WAL.</p>

        <section id="postgresql">
            <title>Dans <postgres/></title>

            <p>La commande <postgres/> <id>COPY</id> permet de charger les informations <backrest/>  dans un tableau.  L'exemple suivant résume cette logique dans une fonction qui peut être utilisée pour effectuer des requêtes en temps réel.</p>

            <execute-list host="{[host-pg1]}">
                <title>Charger la fonction d'information de  <backrest/> dans <postgres/></title>

                <execute user="postgres" show="n">
                    <exe-cmd>mkdir -p {[pg-home-path]}/pgbackrest/doc/example</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>cp -r {[pgbackrest-repo-path]}/doc/example/*
                        {[pg-home-path]}/pgbackrest/doc/example</exe-cmd>
                </execute>

                <execute user="postgres" output="y">
                    <exe-cmd>cat
                        {[pg-home-path]}/pgbackrest/doc/example/pgsql-pgbackrest-info.sql</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>psql -f
                        {[pg-home-path]}/pgbackrest/doc/example/pgsql-pgbackrest-info.sql</exe-cmd>
                </execute>
            </execute-list>

            <p>Vous pouvez à présent utiliser la fonction <code>monitor.pgbackrest_info()</code> pour déterminer la dernière sauvegarde réussie et les WAL archivés pour un dépots de sauvegarde.</p>

            <execute-list host="{[host-pg1]}">
                <title>Interroger la dernière sauvegarde réussie et les WAL archivés</title>

                <execute user="postgres" output="y">
                    <exe-cmd>cat
                        {[pg-home-path]}/pgbackrest/doc/example/pgsql-pgbackrest-query.sql</exe-cmd>
                </execute>

                <execute user="postgres" output="y">
                    <exe-cmd>psql -f
                        {[pg-home-path]}/pgbackrest/doc/example/pgsql-pgbackrest-query.sql</exe-cmd>
                </execute>
            </execute-list>
        </section>

        <section if="{[os-type-is-debian]}" id="jq">
            <title>Utilisez la commande <proper>jq</proper></title>

            <p><proper>jq</proper> est un utilitaire en ligne de commande qui peut facilement extraire des données de JSON.</p>

            <execute-list host="{[host-pg1]}">
                <title>Installer l'utilitaire <proper>jq</proper></title>

                <execute user="root" pre="y">
                    <exe-cmd>apt-get install jq</exe-cmd>
                    <exe-cmd-extra>-y 2>&amp;1</exe-cmd-extra>
                </execute>
            </execute-list>

            <p>Vous pouvez maintenant utiliser <proper>jq</proper> pour obtenir le temps mis par la dernière sauvegarde réussit pour un dépot de sauvegarde</p>

            <execute-list host="{[host-pg1]}">
                <title>Interroger le temps pris par la denière sauvegarde réussi</title>

                <execute user="postgres" output="y">
                    <exe-cmd>
                      pgbackrest --output=json --stanza=demo info |
                          jq '.[0] | .backup[-1] | .timestamp.stop'
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>Ou pour le dernier WAL archivé.</p>

            <execute-list host="{[host-pg1]}">
                <title>Interroger pour obtenir le nom du dernier WAL archivé</title>

                <execute user="postgres" output="y">
                    <exe-cmd>
                      pgbackrest --output=json --stanza=demo info |
                          jq '.[0] | .archive[-1] | .max'
                    </exe-cmd>
                </execute>
            </execute-list>

            <admonition type="note">Cette syntaxe exige <proper>jq v1.5</proper>.</admonition>
            <admonition type="note"><proper>jq</proper> peut arrondir de grands nombres tels que les identificateurs de système.  Testez vos requêtes avec soin vos requêtes avant de les mettres en production.</admonition>
        </section>
    </section>

    <!-- SECTION => RETENTION -->
    <section id="retention" depend="quickstart/perform-backup">
        <title>Rétention</title>

        <p>En général, il est préférable de conserver autant de sauvegardes que possible afin d'offrir une plus grande fenêtre de <link section="/pitr">récupération par PITR</link>, mais il faut également tenir compte de préoccupations pratiques telles que l'espace disque.  Les options de conservation permettent de supprimer les anciennes sauvegardes lorsqu'elles ne sont plus nécessaires.</p>

        <!-- SECTION => RETENTION - FULL -->
        <section id="full">
            <title>Conservation de la sauvegarde complète</title>

            <p>Le paramètre <br-option>repo1-retention-full-type</br-option> détermine comment l'option <br-option>repo1-retention-full</br-option> est interprétée ; soit le nombre de sauvegardes complètes à conserver, soit le nombre de jours de conservation des sauvegardes complètes.  Les nouvelles sauvegardes doivent être effectuées avant leur expiration; Cela signifie que si <br-setting>repo1-retention-full-type=count</br-setting> et <br-setting>repo1-retention-full=2</br-setting> alors il y aura trois sauvegardes complètes stockées avant que la plus ancienne n'expire, ou si <br-setting>repo1-retention-full-type=time</br-setting> et <br-setting>repo1-retention-full=20</br-setting> alors il doit y avoir une sauvegarde complète datant d'au moins 20 jours avant l'expiration. </p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration de l'option <br-option>repo1-retention-full</br-option></title>

                <backrest-config-option section="global" key="repo1-retention-full">2</backrest-config-option>
            </backrest-config>

            <p>Le paramètre est fixé à <br-setting>repo1-retention-full=2</br-setting> mais actuellement il n'y a qu'une seule sauvegarde complète de sorte que la prochaine sauvegarde complète qui sera exécutée ne fera expirer aucune autre sauvegarde complète.</p>

            <execute-list host="{[host-pg1]}">
                <title>Effectuer une sauvegarde complète</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=full
                        --log-level-console=detail backup</exe-cmd>
                    <exe-highlight>archive retention on backup {[backup-full-first]}|remove archive</exe-highlight>
                </execute>

                <execute user="postgres" show="n" variable-key="backup-full-second">
                    <exe-cmd>{[cmd-backup-last]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Des archives <i>ont</i> expiré puisque des segments WAL ont été générés avant la plus ancienne sauvegarde. Ils ne sont pas utiles pour la restauration &amp;mdash ; seuls les segments WAL générés après une sauvegarde peuvent être utilisés lors de la restauration de cette sauvegarde.</p>

            <execute-list host="{[host-pg1]}">
                <title>Effectuer une sauvegarde complète</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=full
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>expire full backup set\: {[backup-full-first]}|archive retention on backup {[backup-full-second]}|remove archive</exe-highlight>
                </execute>
            </execute-list>

            <p>La sauvegarde complète <id>{[backup-full-first]}</id> a expiré et la conservation des archives est basée sur la sauvegarde <id>{[backup-full-second]}</id> qui est désormais la plus ancienne sauvegarde complète.</p>
        </section>

        <!-- SECTION => RETENTION - DIFF -->
        <section id="diff">
            <title>Rétention de la sauvegarde différentielle</title>

            <p>Modifiez <br-option>repo1-retention-diff</br-option> sur le nombre de sauvegardes différentielles souhaitées.  Les sauvegardes différentiels ne reposent que sur la sauvegarde complète antérieure, de sorte qu'il est possible de créer un ensemble de sauvegardes différentielles pour le dernier jour ou plus.  Cela permet de restaurer rapidement vers un point de sauvegarde dans le temps (points-in-time) mais diminue la quantité globale d'espace disponible.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration de <br-option>repo1-retention-diff</br-option></title>

                <backrest-config-option section="global" key="repo1-retention-diff">1</backrest-config-option>
            </backrest-config>

            <p>La sauvegarde effectuera <br-setting>repo1-retention-diff=1</br-setting> donc deux différentiels devront être réalisés avant que l'un d'entre eux ne soit expiré.  Une sauvegarde incrémentale est ajoutée pour illustrer l'expiration incrémentale.  Les sauvegardes incrémentales ne peuvent pas expirer de façon individuelle &amp;mdash ; elles expirent toujours avec leur sauvegarde complète ou différentielle correspondante.</p>

            <execute-list host="{[host-pg1]}">
                <title>Effectuer des sauvegardes différentielles et incrémentales</title>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=diff backup</exe-cmd>
                </execute>

                <execute user="postgres" show="n" variable-key="backup-diff-second">
                    <exe-cmd>{[cmd-backup-last]}</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=incr backup</exe-cmd>
                </execute>
            </execute-list>

            <p>Le fait de procéder maintenant à une sauvegarde différentielle fera expirer les sauvegardes différentielles et incrémentales précédentes, ne laissant qu'une seule sauvegarde différentielle.</p>

            <execute-list host="{[host-pg1]}">
                <title>Effectuer une sauvegarde différentielle</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=diff
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>expire diff backup set: {[backup-diff-second]}</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => RETENTION - ARCHIVE -->
        <section id="archive">
            <title>Rétention des archives</title>

            <p>Bien que <backrest/> supprime automatiquement les segments WAL archivés lors de l'expiration des sauvegardes (la valeur par défaut d'expiration des WAL pour les sauvegardes complètes se base sur l'option <br-option>repo1-retention-full</br-option>), il peut être utile de faire expirer les archives de manière plus agressive pour économiser de l'espace disque.  Notez que les sauvegardes complètes sont considérées comme des sauvegardes différentielles dans le but d'une conservation différentielle des archives.</p>

            <p>Les archives qui expirent ne supprimeront jamais les segments de WAL qui sont nécessaires pour rendre une sauvegarde cohérente. Toutefois, étant donné que la récupération ponctuelle (PITR) ne fonctionne que sur un flux WAL continu, il convient d'être prudent en cas d'expiration agressive des archives en dehors du processus normal d'expiration des sauvegardes.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
                <title>Configuration de <br-option>repo1-retention-diff</br-option></title>

                <backrest-config-option section="global" key="repo1-retention-diff">2</backrest-config-option>
            </backrest-config>

            <execute-list host="{[host-pg1]}">
                <title>Effectuer une sauvegarde différentielle</title>

                <execute user="postgres" show="n" variable-key="backup-diff-first">
                    <exe-cmd>{[cmd-backup-last]}</exe-cmd>
                </execute>

                <!-- Push a few WAL segments to make the example below more interesting -->
                <execute user="postgres" show="n">
                    <exe-cmd>psql -c "
                        select pg_create_restore_point('generate WAL'); select {[pg-switch-wal]}();
                        select pg_create_restore_point('generate WAL'); select {[pg-switch-wal]}();"</exe-cmd>
                </execute>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=diff
                        --log-level-console=info backup</exe-cmd>
                    <exe-highlight>new backup label</exe-highlight>
                </execute>

                <execute user="postgres" show="n" variable-key="backup-diff-second">
                    <exe-cmd>{[cmd-backup-last]}</exe-cmd>
                </execute>
            </execute-list>

            <execute-list host="{[host-pg1]}">
                <title>Expire archive</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --log-level-console=detail
                        --repo1-retention-archive-type=diff --repo1-retention-archive=1 expire</exe-cmd>
                    <exe-highlight>archive retention on backup {[backup-diff-first]}|remove archive</exe-highlight>
                </execute>
            </execute-list>

            <p>La sauvegarde différentielle <id>{[backup-diff-first]}</id> a archivé des segments WAL qui doivent être conservés pour rendre les anciennes sauvegardes cohérentes même si elles ne peuvent pas être jouées ultérieurement avec PITR. Les segments WAL générés après la sauvegarde <id>{[backup-diff-first]}</id> mais avant <id>{[backup-diff-second]}</id> sont supprimés. Les segments WAL générés après la nouvelle sauvegarde <id>{[backup-diff-second]}</id> sont conservés et peuvent être utilisés pour le PITR.</p>

            <p>Étant donné que les sauvegardes complètes sont considérées comme des sauvegardes différentielles pour la conservation différentielle des archives, si une sauvegarde complète est maintenant effectuée avec les mêmes paramètres, seule l'archive de cette sauvegarde complète est conservée pour PITR.</p>
        </section>
    </section>

    <!-- SECTION => RESTORE -->
    <section id="restore" depend="quickstart/perform-backup">
        <title>Restauration</title>

        <p>La section Restauration introduit des fonctionnalités supplémentaires de la commande <cmd>restore</cmd>.</p>

        <!-- ******************************************************************************************************************* -->
        <section id="ownership">
            <title>Propriétaire du fichier</title>

            <p>Lorsqu'un <cmd>restore</cmd> est exécuté en tant qu'utilisateur non root (scénario typique), tous les fichiers restaurés appartiendront à l'utilisateur/groupe qui exécute le <backrest/>.  Si les fichiers existants ne sont pas la propriété de l'utilisateur/groupe en cours d'exécution, une erreur se produira si le propriétaire ne peut pas être mise à jour pour l'utilisateur/groupe en cours d'exécution.  Dans ce cas, la propriété du fichier devra être mise à jour par un utilisateur privilégié avant que la restauration ne puisse être réexécutée.</p>

            <p>Lorsqu'un <cmd>restore</cmd> est exécuté en tant qu'utilisateur <id>root</id>, le <backrest/> tentera de recréer la propriété enregistrée dans le manifeste de la sauvegarde.  Seuls les <b>noms</b> des utilisateurs/groupes  sont stockés dans le manifeste, de sorte que les mêmes noms doivent exister sur l'hôte de restauration pour que cela fonctionne.  Si le nom de l'utilisateur/groupe ne peut être trouvé localement, l'utilisateur/groupe du répertoire de données <postgres/> sera utilisé et enfin si l'utilisateur/groupe du répertoire de données ne peut être associé à un nom, <id>root</id> sera utilisé.</p>
        </section>

        <!-- SECTION => RESTORE - DELTA -->
        <section id="option-delta">
            <title>Option de Delta</title>

            <p>Dans la section <link section="/quickstart/perform-restore">Restauration d'une sauvegarde</link> du <link section="/quickstart">Guide de démarrage rapide</link> a exigé que le répertoire de l'instance soit vidé avant d'effectuer le <cmd>restore</cmd>. L'option <br-option>delta</br-option> permet à <backrest/> de déterminer automatiquement quels fichiers du répertoire de l'instance de base de données peuvent être préservés et lesquels doivent être restaurés à partir de la sauvegarde &amp;mdash ; elle permet également de <i>supprimer</i> les fichiers non présents dans le manifeste de sauvegarde afin de se débarrasser des modifications divergeantes. Cette opération est réalisée en calculant un  hachage cryptographique <link url="https://en.wikipedia.org/wiki/SHA-1">SHA-1</link> sur chacun des fichiers présents dans le répertoire de données de l'instance.  Si le hachage <id>SHA-1</id> ne correspond pas au hachage stocké dans la sauvegarde, le fichier sera restauré.  Cette opération est très efficace lorsqu'elle est combinée avec l'option <br-option>process-max</br-option>. Étant donné que le serveur <postgres/> est arrêté pendant la restauration, il est possible d'utiliser un plus grand nombre de processus que ce qui pourrait être envisagé durant une sauvegarde (lorsque l'instance <postgres/> est en cours d'exécution).</p>

            <execute-list host="{[host-pg1]}">
                <title>Arrêt de l'instance  {[postgres-cluster-demo]}, effectuer une restauration delta</title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
                </execute>

                <execute user="postgres" output="y" filter="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta
                        --log-level-console=detail restore</exe-cmd>
                    <exe-highlight>demo\/PG_VERSION - exists and matches backup|remove invalid files|rename global\/pg_control</exe-highlight>
                </execute>
            </execute-list>

            <execute-list host="{[host-pg1]}">
                <title>Redémarrage de <postgres/></title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => RESTORE - DELTA -->
        <section id="option-db-include">
            <title>Restaurer des bases de données sélectionnées</title>

            <p>Dans certains cas, il peut être intéressant de restaurer de façon sélective des bases de données spécifiques à partir d'une sauvegarde d'instance.  Cela peut être fait pour des raisons de performance ou pour déplacer les bases de données sélectionnées vers une machine qui n'a pas assez d'espace pour restaurer l'ensemble de la sauvegarde de l'instance </p>

            <p>Pour illustrer cette fonctionnalité, deux bases de données sont créées : test1 et test2.  Une nouvelle sauvegarde est effectuée afin que <backrest/> soit informé des nouvelles bases de données.</p>

            <execute-list host="{[host-pg1]}">
                <title>Créer deux bases de données de test et effectuer une sauvegarde</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "create database test1;"
                    </exe-cmd>
                </execute>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "create database test2;"
                    </exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=incr backup</exe-cmd>
                </execute>
            </execute-list>

            <p>Chaque base de données de test sera alimentée par des tables et des données pour illustrer que la restauration fonctionne avec une restauration sélective.</p>

            <execute-list host="{[host-pg1]}">
                <title>Créer une table de test dans chaque base de données</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "create table test1_table (id int);
                                 insert into test1_table (id) values (1);" test1
                    </exe-cmd>
                </execute>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "create table test2_table (id int);
                                 insert into test2_table (id) values (2);" test2
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>L'une des principales raisons de recourir à la restauration sélective est le gain d'espace.  La taille de la base de données test1 est indiquée ici afin de pouvoir la comparer avec l'utilisation du disque après une restauration sélective.</p>

            <execute-list host="{[host-pg1]}">
                <title>Afficher l'espace utilisé par la base de données test1</title>

                <execute user="postgres" show="n" variable-key="database-test1-oid">
                    <exe-cmd>
                        psql -Atc "select oid from pg_database where datname = 'test1'"
                    </exe-cmd>
                </execute>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        du -sh {[pg-path]}/base/{[database-test1-oid]}
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>Si la base de données à restaurer n'est pas connue, utilisez l'option de commande <cmd>info</cmd> command <br-option>set</br-option> pour découvrir les bases de données qui font partie du jeu de sauvegarde.</p>

            <execute-list host="{[host-pg1]}">
                <title>Afficher la liste des bases de données de la sauvegarde</title>

                <execute user="postgres" show="n" variable-key="backup-last-incr">
                    <exe-cmd>{[cmd-backup-last]}</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]}
                        {[dash]}-set={[backup-last-incr]} info</exe-cmd>
                    <exe-highlight>database list</exe-highlight>
                </execute>
            </execute-list>

            <p>Arrêtez l'instance et ne restaurez que la base de données test2.  Les bases de données intégrées (<id>template0</id>, <id>template1</id>, et <id>postgres</id>) sont toujours restaurées.</p>

            <execute-list host="{[host-pg1]}">
                <title>Restauration de la dernière sauvegarde incluant uniquement la base de données test2</title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta
                        {[dash]}-db-include=test2 restore</exe-cmd>
                </execute>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Une fois la récupération terminée, la base de données test2 contiendra toutes les tables et données créées précédemment.</p>

            <execute-list host="{[host-pg1]}">
                <title>Démontration que la base de données test2 a été récupérée</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "select * from test2_table;" test2
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>La base de données <quote>test1</quote>, malgré une récupération réussie, n'est pas accessible.  Cela est dû au fait que la base de données entière a été restaurée sous forme de fichiers épars et mis à zéro.  <postgres/> peut appliquer des WALs avec succès sur les fichiers mis à zéro mais la base de données dans son ensemble ne sera pas valide car les fichiers clés ne contiennent pas de données.  Ceci est destiné à éviter que la base de données soit accidentellement utilisée alors qu'elle pourrait contenir des données partielles qui ont été appliquées lors de la relecture de WAL.</p>

            <execute-list host="{[host-pg1]}">
                <title>Tenter de se connecter à la base de données test1 produira une erreur</title>

                <execute user="postgres" output="y" filter="n" err-expect="2">
                    <exe-cmd>
                        psql -c "select * from test1_table;" test1
                    </exe-cmd>
                    <exe-highlight>relation mapping file.*contains invalid data</exe-highlight>
                </execute>
            </execute-list>

            <p>Comme la base de données test1 est restaurée avec des fichiers épars et mis à zéro, elle ne nécessitera qu'autant d'espace que la quantité de WAL qui est écrite pendant la récupération.  Bien que la quantité de WAL générée lors d'une sauvegarde et appliquée lors de la récupération puisse être importante, elle ne représentera généralement qu'une petite fraction de la taille totale de la base de données, en particulier pour les grandes bases de données où cette fonctionnalité est la plus susceptible d'être utile.</p>

            <p>Il est clair que la base de données test1 utilise beaucoup moins d'espace disque pendant la restauration sélective qu'elle ne l'aurait fait si toute la base de données avait été restaurée.</p>

            <execute-list host="{[host-pg1]}">
                <title>Afficher l'espace utilisé par la base de données test1 après la récupération</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        du -sh {[pg-path]}/base/{[database-test1-oid]}
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>À ce stade, la seule action qui peut être entreprise sur la base de données de test1 invalide est <id>drop database</id>. <backrest/> ne supprime pas automatiquement la base de données puisque cela ne peut pas être fait tant que la récupération n'est pas terminée et que l'instance n'est pas accessible.</p>

            <execute-list host="{[host-pg1]}">
                <title>Supprimer la base de données du test1</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "drop database test1;"
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>Maintenant que la base de données invalide du test1 a été supprimée, il ne reste plus que le test2 et les bases de données internes.</p>

            <execute-list host="{[host-pg1]}">
                <title>Liste des bases de données restantes</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "select oid, datname from pg_database order by oid;"
                    </exe-cmd>
                    <exe-highlight>test2</exe-highlight>
                </execute>
            </execute-list>
        </section>
    </section>

    <!-- SECTION => PITR -->
    <section id="pitr" depend="quickstart/perform-backup">
        <title>Point-in-Time Recovery</title>

        <p><link section="/quickstart/perform-restore">Restaurer une sauvegarde</link> de la section <link section="/quickstart">Démarrage Rapide</link> effectue une récupération par défaut, qui doit se poursuivre jusqu'à la fin du flux de WAL.  En cas de défaillance matérielle, c'est généralement le meilleur choix, mais pour les scénarios de corruption de données (qu'elles soient d'origine machine ou humaine), la récupération ponctuelle (PITR) est souvent plus appropriée</p>

        <p>La récupération ponctuelle (PITR) permet de lire les WAL depuis la dernière sauvegarde jusqu'à une heure, un identifiant de transaction ou un point de récupération spécifié.  Pour les scénarios de récupération courants, la récupération basée sur le temps est sans doute la plus utile.  Un scénario de récupération typique consiste à restaurer une table qui a été accidentellement supprimée ou des données qui ont été accidentellement effacées.  La récupération d'une table supprimée est plus spectaculaire, c'est donc l'exemple donné ici, mais des données supprimées seraient récupérées exactement de la même manière.</p>

        <execute-list host="{[host-pg1]}">
            <title>Sauvegarder l'instance {[postgres-cluster-demo]} et créer une table avec des données très importantes</title>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=diff backup</exe-cmd>
            </execute>

            <execute user="postgres" output="y">
                <exe-cmd>
                    psql -c "begin;
                             create table important_table (message text);
                             insert into important_table values ('{[test-table-data]}');
                             commit;
                             select * from important_table;"
                </exe-cmd>
                <exe-highlight>{[test-table-data]}</exe-highlight>
            </execute>
        </execute-list>

        <p>Il est important de faire correspondre l'heure à celle calculée par <postgres/> et d'inclure les décalages de fuseau horaire. Cela réduit la possibilité de conversions involontaires de fuseau horaire et d'un résultat de récupération inattendu.</p>

        <execute-list host="{[host-pg1]}">
            <title>Obtenez l'heure à partir de <postgres/></title>

            <execute user="postgres" show="n">
                <exe-cmd>sleep 1</exe-cmd>
            </execute>

            <execute user="postgres" output="y" filter="n" variable-key="time-recovery-timestamp">
                <exe-cmd>
                    psql -Atc "select current_timestamp"
                </exe-cmd>
            </execute>

            <execute user="postgres" show="n">
                <exe-cmd>sleep 1</exe-cmd>
            </execute>
        </execute-list>

        <p>Maintenant que l'heure a été enregistrée, le tableau est supprimé.  En pratique, il est beaucoup plus difficile de trouver l'heure exacte à laquelle la table a été supprimée que dans cet exemple.  Il n'est peut-être pas possible de trouver l'heure exacte, mais un travail de recherche devrait vous permettre de vous en rapprocher.</p>

        <execute-list host="{[host-pg1]}">
            <title>Supprimer la table importante</title>

            <execute user="postgres" output="y" err-expect="1">
                <exe-cmd>psql -c "begin;
                                  drop table important_table;
                                  commit;
                                  select * from important_table;"</exe-cmd>
                <exe-highlight>does not exist</exe-highlight>
            </execute>
        </execute-list>

        <p>Maintenant, la restauration peut être effectuée avec une récupération basée sur le temps pour récupérer la table perdue.</p>

        <execute-list host="{[host-pg1]}">
            <title>Arrêtez <postgres/>, restaurez l'instance {[postgres-cluster-demo]} à <id>{[time-recovery-timestamp]}</id>, et affichez le fichier <file>recovery.conf</file></title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
            </execute>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta
                    {[dash]}-type=time "{[dash]}-target={[time-recovery-timestamp]}"
                    --target-action=promote restore</exe-cmd>
            </execute>

            <execute user="root" show="n">
                <exe-cmd>rm {[postgres-log-demo]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y">
                <exe-cmd>cat {[postgres-recovery-demo]}</exe-cmd>
                <exe-highlight>recovery_target_time</exe-highlight>
            </execute>
        </execute-list>

        <p>Le fichier <file>recovery.conf</file> a été généré automatiquement par <backrest/>, de sorte que <postgres/> peut être lancé immédiatement. Une fois que <postgres/> a terminé la récupération, la table existera de nouveau et pourra être interrogée.</p>

        <execute-list host="{[host-pg1]}">
            <title>Démarrez <postgres/> et vérifiez que la table important existe</title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-start]}</exe-cmd>
            </execute>

            <execute user="postgres" show="n">
                <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y">
                <exe-cmd>psql -c "select * from important_table"</exe-cmd>
                <exe-highlight>{[test-table-data]}</exe-highlight>
            </execute>
        </execute-list>

        <p>Les traces de <postgres/> contiennent également des informations précieuses.  Ils indiqueront l'heure et la transaction où la récupération s'est arrêtée et donnera également l'heure de la dernière transaction appliquée.</p>

        <execute-list host="{[host-pg1]}">
            <title>Examiner la sortie des traces <postgres/></title>

            <execute user="postgres" output="y">
                <exe-cmd>cat {[postgres-log-demo]}</exe-cmd>
                <exe-highlight>recovery stopping before|last completed transaction|starting point-in-time recovery</exe-highlight>
            </execute>
        </execute-list>

        <p>Cet exemple a été truqué pour donner le bon résultat.  Si une sauvegarde après le temps requis est choisie, alors <postgres/> ne pourra pas récupérer la table perdue. <postgres/> ne peut jouer que vers l'avant, pas vers l'arrière.  Pour le démontrer, la table importante doit être abandonnée (de nouveau).</p>

        <execute-list host="{[host-pg1]}">
            <title>Supprimer la table importante (de nouveau)</title>

            <execute user="postgres" output="y" err-expect="1">
                <exe-cmd>psql -c "begin;
                                  drop table important_table;
                                  commit;
                                  select * from important_table;"</exe-cmd>
                <exe-highlight>does not exist</exe-highlight>
            </execute>
        </execute-list>

        <p>Prenez maintenant une nouvelle sauvegarde et essayez de récupérer à partir de la nouvelle sauvegarde en spécifiant l'option <br-option>{{[dash]}-set</br-option>. La commande <cmd>info</cmd> peut être utilisée pour trouver le nouveau label de la sauvegarde.</p>

        <execute-list host="{[host-pg1]}">
            <title>Effectuer une sauvegarde et obtenir des informations sur la sauvegarde</title>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=incr backup</exe-cmd>
            </execute>

            <execute user="postgres" show="n" variable-key="backup-last">
                <exe-cmd>{[cmd-backup-last]}</exe-cmd>
            </execute>

            <execute user="postgres" filter="n" output="y">
                <exe-cmd>{[project-exe]} info</exe-cmd>
                <exe-highlight>{[backup-last]}</exe-highlight>
            </execute>
        </execute-list>

        <execute-list host="{[host-pg1]}">
            <title>Tentative de récupération à partir de la sauvegarde spécifiée</title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
            </execute>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta
                     {[dash]}-set={[backup-last]}
                     {[dash]}-type=time "{[dash]}-target={[time-recovery-timestamp]}" {[dash]}-target-action=promote restore</exe-cmd>
            </execute>

            <execute user="root" show="n">
                <exe-cmd>rm {[postgres-log-demo]}</exe-cmd>
            </execute>

            <execute user="root">
                <exe-cmd>{[pg-cluster-start]}</exe-cmd>
            </execute>

            <execute user="postgres" show="n">
                <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y" err-expect="1">
                <exe-cmd>psql -c "select * from important_table"</exe-cmd>
                <exe-highlight>does not exist</exe-highlight>
            </execute>
        </execute-list>

        <p>En regardant le journal de sortie, il n'est pas évident que la récupération n'a pas réussi à restaurer la table.  La solution consiste à rechercher la présence des messages de journal <quote>recovery stopping before...</quote> (arrêt de la récupération avant...) et <quote>last completed transaction..</quote> (dernière transaction effectuée...).  S'ils ne sont pas présents, alors la récupération au point spécifié dans le temps n'a pas réussi.</p>

        <execute-list host="{[host-pg1]}">
            <title>Examiner la sortie du journal <postgres/> pour constater que la récupération n'a pas réussi</title>

            <execute user="postgres" output="y">
                <exe-cmd>cat {[postgres-log-demo]}</exe-cmd>
                <exe-highlight>starting point-in-time recovery|consistent recovery state reached</exe-highlight>
            </execute>
        </execute-list>

        <p>Le comportement par défaut pour la restauration basée sur le temps, si l'option <br-option>{[dash]}-set</br-option> n'est pas spécifiée, est de tenter de découvrir une sauvegarde antérieure pour la rejouer. Si un jeu de sauvegarde ne peut pas être trouvé, alors la restauration se fera par défaut sur la dernière sauvegarde qui, comme indiqué précédemment, peut ne pas donner le résultat souhaité.</p>

        <execute-list host="{[host-pg1]}">
            <title>Arrêter <postgres/>, restaurer à partir de la sauvegarde sélectionnée automatiquement, et démarrez <postgres/></title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
            </execute>

            <execute user="postgres">
                <exe-cmd>
                    {[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta
                        {[dash]}-type=time "{[dash]}-target={[time-recovery-timestamp]}"
                        {[dash]}-target-action=promote restore
                </exe-cmd>
            </execute>

            <execute user="root" show="n">
                <exe-cmd>rm {[postgres-log-demo]}</exe-cmd>
            </execute>

            <execute user="root">
                <exe-cmd>{[pg-cluster-start]}</exe-cmd>
            </execute>

            <execute user="postgres" show="n">
                <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y">
                <exe-cmd>psql -c "select * from important_table"</exe-cmd>
                <exe-highlight>{[test-table-data]}</exe-highlight>
            </execute>
        </execute-list>

        <p>Maintenant, la sortie du journal (traces) contiendra les messages attendus <quote>recovery stopping before...</quote> (arrêt de la récupération avant...) et <quote>last completed transaction...</quote> (dernière transaction terminée...) indiquant que la récupération a réussi.</p>

        <execute-list host="{[host-pg1]}">
            <title>Examiner la sortie du journal (traces) de <postgres/> pour les messages indiquant le succès</title>

            <execute user="postgres" output="y">
                <exe-cmd>cat {[postgres-log-demo]}</exe-cmd>
                <exe-highlight>recovery stopping before|last completed transaction|starting point-in-time recovery</exe-highlight>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => S3-SUPPORT -->
    <section id="s3-support" if="'{[s3-all]}' ne 'y'" depend="/quickstart/configure-archiving">
        <title>Support de S3-Compatible Object Store</title>

        <block id="s3-setup">
            <block-variable-replace key="s3-setup-host">{[host-pg1]}</block-variable-replace>
            <block-variable-replace key="s3-setup-user">postgres</block-variable-replace>
            <block-variable-replace key="s3-setup-config-owner">postgres:postgres</block-variable-replace>
            <block-variable-replace key="s3-setup-create-bucket">y</block-variable-replace>
        </block>

        <p>Un rôle doit être créé pour exécuter <backrest/> et les permissions du <quote>bucket</quote> doivent être définies de manière aussi restrictive que possible.  Cet exemple de politique <proper>Amazon S3</proper> restreindra toutes les lectures et écritures dans la zone de stockage et le chemin du dépôt.</p>

        <code-block title="Sample Amazon S3 Policy">
            {
                "Version": "2012-10-17",
                "Statement": [
                    {
                        "Effect": "Allow",
                        "Action": [
                            "s3:ListBucket"
                        ],
                        "Resource": [
                            "arn:aws:s3:::{[s3-bucket]}"
                        ],
                        "Condition": {
                            "StringEquals": {
                                "s3:prefix": [
                                    "",
                                    "{[s3-repo]}"
                                ],
                                "s3:delimiter": [
                                    "/"
                                ]
                            }
                        }
                    },
                    {
                        "Effect": "Allow",
                        "Action": [
                            "s3:ListBucket"
                        ],
                        "Resource": [
                            "arn:aws:s3:::{[s3-bucket]}"
                        ],
                        "Condition": {
                            "StringLike": {
                                "s3:prefix": [
                                    "{[s3-repo]}/*"
                                ]
                            }
                        }
                    },
                    {
                        "Effect": "Allow",
                        "Action": [
                            "s3:PutObject",
                            "s3:GetObject",
                            "s3:DeleteObject"
                        ],
                        "Resource": [
                            "arn:aws:s3:::{[s3-bucket]}/{[s3-repo]}/*"
                        ]
                    }
                ]
            }
        </code-block>

        <p>Les commandes sont exécutées exactement comme si le dépôt était stocké sur un disque local.</p>

        <execute-list host="{[host-pg1]}">
            <title>Create the stanza</title>

            <execute user="postgres" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info stanza-create</exe-cmd>
                <exe-highlight>completed successfully</exe-highlight>
            </execute>
        </execute-list>

        <p>Le temps de création des fichiers dans les magasins d'objets est relativement lent, les commandes bénéficient donc d'une augmentation de <br-option>process-max</br-option> pour paralléliser la création des fichiers.</p>

        <execute-list host="{[host-pg1]}">
            <title>Sauvegarder l'instance {[postgres-cluster-demo]}</title>

            <execute user="postgres" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]}
                    --log-level-console=info backup</exe-cmd>
                <exe-highlight>no prior backup exists|full backup size</exe-highlight>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => REPOSITORY HOST -->
    <section id="delete-stanza" depend="/quickstart/create-stanza">
        <title>Supprimer un stanza</title>

        <cmd-description key="stanza-delete"/>

        <execute-list host="{[host-pg1]}">
            <title>Stopper l'instance <postgres/> à supprimer</title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[host-pg1]}">
            <title>Stopper <backrest/> pour le stanza</title>

            <execute user="postgres" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info stop</exe-cmd>
                <exe-highlight>completed successfully</exe-highlight>
            </execute>
        </execute-list>

        <execute-list host="{[host-pg1]}">
            <title>Supprimer le stanza</title>

            <execute user="postgres" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info stanza-delete</exe-cmd>
                <exe-highlight>completed successfully</exe-highlight>
            </execute>

            <execute user="root" show="n">
                <exe-cmd>{[pg-cluster-start]}</exe-cmd>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => REPOSITORY HOST -->
    <section id="repo-host" depend="/quickstart/configure-archiving">
        <title>Hote de référentiel de sauvegarde dédié</title>

        <p>La configuration décrite dans section <link section="/quickstart">Déamarrage Rapide</link> convient aux installations simples, mais pour les configurations d'entreprise, il est plus courant d'avoir un hôte <host>repository</host> dédié où sont stockés les sauvegardes et les fichiers d'archive WAL. Cela permet de séparer les sauvegardes et les archives WAL du serveur de base de données, de sorte que les défaillances de l'hôte <host>database</host> ont moins d'impact.  Il est toujours judicieux d'utiliser un logiciel de sauvegarde traditionnel pour sauvegarder l'hôte dédié au sauvegarde <host>repository</host>.</p>

        <p>Sur l'hôte <postgres/>, l'option <br-option>pg1-path</br-option> doit être le chemin de la grappe PostgreSQL locale et aucune option <br-option>pg1-host</br-option> ne doit être configurée. Lors de la configuration d'un hôte de dépôt, le fichier de configuration <backrest/> doit avoir l'option <br-option>pg-host</br-option> configurée pour se connecter aux instances primaire et de secours (le cas échéant). L'hôte de dépôt a la seule configuration <backrest/> qui doit connaître plus d'un hôte <postgres/>. L'ordre n'a pas d'importance, par exemple pg1-path/pg1-host, pg2-path/pg2-host peut être le primaire ou le secondaire.</p>

        <section id="install">
            <title>Installation</title>

            <p>Un nouvel hôte nommé <host>repository</host> est créé pour stocker les sauvegardes du cluster.</p>

            <host-add id="{[host-repo1-id]}" name="{[host-repo1]}" user="{[host-repo1-user]}" image="{[host-repo1-image]}" os="{[os-type]}" mount="{[host-repo1-mount]}" option="{[host-option]}"/>

            <p>L'utilisateur <user>{[br-user]}</user> est créé pour détenir le référentiel <backrest/>.  Tout utilisateur peut être propriétaire du référentiel mais il est préférable de ne pas utiliser <user>postgres</user> (s'il existe) pour éviter toute confusion.</p>

            <execute-list host="{[host-repo1]}">
                <title>Create <user>{[br-user]}</user> user</title>

                <execute if="{[os-type-is-debian]}" user="root">
                    <exe-cmd>adduser --disabled-password --gecos "" {[br-user]}</exe-cmd>
                </execute>
                <execute if="{[os-type-is-centos]}" user="root">
                    <exe-cmd>groupadd {[br-group]}</exe-cmd>
                </execute>
                <execute if="{[os-type-is-centos]}" user="root">
                    <exe-cmd>adduser -g{[br-group]} -n {[br-user]}</exe-cmd>
                </execute>
            </execute-list>

            <block id="br-install">
                <block-variable-replace key="br-install-host">{[host-repo1]}</block-variable-replace>
                <block-variable-replace key="br-install-user">{[br-user]}</block-variable-replace>
                <block-variable-replace key="br-install-group">{[br-group]}</block-variable-replace>
            </block>

            <block id="br-install-repo">
                <block-variable-replace key="br-install-host">{[host-repo1]}</block-variable-replace>
                <block-variable-replace key="br-install-user">{[br-user]}</block-variable-replace>
                <block-variable-replace key="br-install-group">{[br-group]}</block-variable-replace>
            </block>
        </section>

        <section id="setup-ssh">
            <title>Configuration de SSH par échange de clés</title>

            <block id="setup-ssh-intro">
                <!-- ??? Bogus variable is set because the syntax currently requires at least one -->
                <block-variable-replace key="bogus"></block-variable-replace>
            </block>

            <execute-list host="{[host-repo1]}">
                <title>Create <host>{[host-repo1]}</host> host key pair</title>

                <execute user="{[br-user]}">
                    <exe-cmd>mkdir -m 750 {[br-home-path]}/.ssh</exe-cmd>
                </execute>
                <execute user="{[br-user]}">
                    <exe-cmd>ssh-keygen -f {[br-home-path]}/.ssh/id_rsa
                        -t rsa -b 4096 -N ""</exe-cmd>
                </execute>
            </execute-list>

            <block id="setup-ssh">
                <block-variable-replace key="setup-ssh-host">{[host-pg1]}</block-variable-replace>
                <block-variable-replace key="setup-ssh-user">postgres</block-variable-replace>
                <block-variable-replace key="setup-ssh-user-home-path">{[pg-home-path]}</block-variable-replace>
            </block>

            <admonition type="note">ssh a été configuré pour permettre uniquement l'exécution de <backrest/> via ssh sans mot de passe. Cela renforce la sécurité en cas de détournement de l'un des comptes de service.</admonition>

            <!-- <block if="{[pg-version]} >= 11" id="setup-ssh">
                <block-variable-replace key="setup-ssh-host">{[host-pg1]}</block-variable-replace>
                <block-variable-replace key="setup-ssh-user">pgbackrest</block-variable-replace>
                <block-variable-replace key="setup-ssh-user-home-path">{[br-home-path]}</block-variable-replace>
            </block> -->
        </section>

        <!-- SECTION => REPOSITORY HOST - INSTALL/CONFIGURE -->
        <section id="config">
            <title>Configuration</title>

            <backrest-config host="{[host-repo1]}" show="n" owner="{[br-user]}:{[br-group]}" file="{[backrest-config-demo]}">
                <title>Configuration du chemin du dépôt de <backrest/> </title>

                <backrest-config-option section="global" key="repo1-path">{[backrest-repo-path]}</backrest-config-option>
            </backrest-config>

            <p>L'hôte <host>repository</host> doit être configuré avec <host>{[hôte-pg1]}</host> hôte/utilisateur et base de données. Le primaire sera configuré comme <id>pg1</id> pour permettre l'ajout d'une instance secondaire plus tard.</p>

            <backrest-config host="{[host-repo1]}" owner="{[br-user]}:{[br-group]}" file="{[backrest-config-demo]}">
                <title>Configuration de <br-option>pg1-host</br-option>/<br-option>pg1-host-user</br-option> et <br-option>pg1-path</br-option></title>

                <backrest-config-option section="demo" key="pg1-path">{[pg-path]}</backrest-config-option>
                <backrest-config-option section="demo" key="pg1-host">{[host-pg1]}</backrest-config-option>
                <!-- <backrest-config-option if="{[pg-version]} >= 11" section="demo" key="pg1-host-user">{[br-user]}</backrest-config-option> -->

                <backrest-config-option section="global" key="start-fast">y</backrest-config-option>
                <backrest-config-option section="global" key="repo1-retention-full">2</backrest-config-option>

                <backrest-config-option section="global" key="log-level-stderr">off</backrest-config-option>
                <backrest-config-option section="global" key="log-timestamp">n</backrest-config-option>
            </backrest-config>

            <p>L'hôte de la base de données doit être configuré avec l'hôte/utilisateur du référentiel de sauvegarde <host>repository</host>.  La valeur par défaut de l'option <br-option>repo1-host-user</br-option> est <id>pgbackrest</id>.  Si l'utilisateur <id>postgres</id> effectue des restaurations, il est préférable de ne pas l'autoriser à effectuer des sauvegardes.  Toutefois, l'utilisateur <id>postgres</id> peut lire directement le dépôt s'il est dans le même groupe que l'utilisateur <id>pgbackrest</id>.</p>

            <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}" reset="y">
                <title>Configure <br-option>repo1-host</br-option>/<br-option>repo1-host-user</br-option></title>

                <backrest-config-option section="demo" key="pg1-path">{[pg-path]}</backrest-config-option>

                <backrest-config-option section="global" key="repo1-host">{[host-repo1]}</backrest-config-option>

                <backrest-config-option section="global" key="log-level-file">detail</backrest-config-option>

                <backrest-config-option section="global" key="log-level-stderr">off</backrest-config-option>
                <backrest-config-option section="global" key="log-timestamp">n</backrest-config-option>
            </backrest-config>

            <p>Les commandes sont exécutées de la même manière que sur une configuration à hôte unique, sauf que certaines commandes telles que <cmd>backup</cmd> et <cmd>expire</cmd> sont exécutées à partir de l'hôte <host>repository</host> au lieu de l'hôte <host>database</host>.</p>

            <!-- <execute-list if="{[pg-version]} >= 11" host="{[host-pg1]}">
                <title>Set permissions required for backup</title>

                <execute user="postgres">
                    <exe-cmd>
                        psql -c "
                            create user pgbackrest;
                            grant pg_read_all_settings to pgbackrest;
                            grant execute on function pg_start_backup(text, boolean, boolean) to pgbackrest;
                            grant execute on function pg_stop_backup(boolean, boolean) to pgbackrest;
                            grant execute on function pg_switch_wal() to pgbackrest;
                            grant execute on function pg_create_restore_point(text) to pgbackrest;"
                    </exe-cmd>
                </execute>
            </execute-list> -->

            <p if="'{[s3-all]}' eq 'y'">Configurer un magasin d'objets compatible S3 si nécessaire.</p>

            <block id="s3-setup" if="'{[s3-all]}' eq 'y'">
                <block-variable-replace key="s3-setup-host">{[host-repo1]}</block-variable-replace>
                <block-variable-replace key="s3-setup-user">{[br-user]}</block-variable-replace>
                <block-variable-replace key="s3-setup-config-owner">{[br-user]}:{[br-group]}</block-variable-replace>
                <block-variable-replace key="s3-setup-create-bucket">n</block-variable-replace>
            </block>

            <p>Créer le Stanza dans le nouveau dépôt.</p>

            <execute-list host="{[host-repo1]}">
                <title>Création du stanza</title>

                <execute user="{[br-user]}" output="y" filter="n">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} stanza-create</exe-cmd>
                </execute>
            </execute-list>

            <p>Vérifiez que la configuration est correcte sur les deux hôtes <host>database</host> et <host>repository</host>. Vous trouverez plus d'informations sur la commande <cmd>check</cmd> dans la section <link section="/quickstart/check-configuration">Contrôle de la configuration</link>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Contrôler la configuration</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} check</exe-cmd>
                </execute>
            </execute-list>

            <execute-list host="{[host-repo1]}">
                <title>Check the configuration</title>

                <execute user="{[br-user]}" output="y" filter="n">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} check</exe-cmd>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => REPOSITORY HOST - PERFORM BACKUP -->
        <section id="perform-backup">
            <title>Effectuer une sauvegarde</title>

            <p>Pour effectuer une sauvegarde de l'instance <postgres/>, lancez <backrest/> avec la commande <cmd>backup</cmd> sur l'hôte <host>repository</host>.</p>

            <execute-list host="{[host-repo1]}">
                <title>Sauvegarde du cluster {[postgres-cluster-demo]}</title>

                <execute user="{[br-user]}" output="y" filter="n">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} backup</exe-cmd>
                </execute>
            </execute-list>

            <p>Depuis qu'un nouveau dépôt a été créé sur l'hôte <host>repository</host>, un avertissement concernant le passage de la sauvegarde incrémentalle à une sauvegarde complète a été émis.</p>
        </section>

        <!-- SECTION => REPOSITORY HOST - PERFORM RESTORE -->
        <section id="perform-restore">
            <title>Restauration d'une sauvegarde</title>

            <p>Pour effectuer une restauration de l'instance <postgres/>, lancez <backrest/> avec la commande <cmd>restore</cmd> sur l'hôte <host>database</host>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Arrêter l'instance {[postgres-cluster-demo]}, restaurer et redémarrer <postgres/></title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta restore</exe-cmd>
                </execute>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>
        </section>
    </section>

    <!-- SECTION => PARALLEL BACKUP-RESTORE -->
    <section id="parallel-backup-restore" depend="repo-host/config">
        <title>Sauvegarde / Restauration en parallèle</title>

        <p><backrest/> offre un traitement parallèle pour améliorer les performances de la compression et du transfert. Le nombre de processus à utiliser pour cette fonction est défini à l'aide de l'option <br-option>--process-max</br-option>.</p>

        <p>Il est généralement préférable de ne pas utiliser plus de 25 % des processeurs disponibles pour la commande <cmd>backup</cmd>.  Les sauvegardes n'ont pas besoin de s'exécuter aussi rapidement dans la mesure où elles sont effectuées régulièrement; le processus de sauvegarde ne doit pas avoir d'impact, si possible, sur les performances de la base de données.</p>

        <p>La commande de restauration peut et doit utiliser toutes les processeurs (CPU) disponibles car pendant une restauration, l'instance <postgres/> est arrêté et il n'y a généralement pas d'autre travail important effectué sur le serveur.  Si le serveur contient plusieurs instances <postgres/>, cela doit être pris en compte dans le paramétrage du parallélisme de la restauration.</p>

        <execute-list host="{[host-repo1]}">
            <title>Effectuer une sauvegarde avec un seul processus</title>

            <execute user="{[br-user]}">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=full backup</exe-cmd>
            </execute>
        </execute-list>

        <backrest-config host="{[host-repo1]}" owner="{[br-user]}:{[br-group]}" file="{[backrest-config-demo]}">
            <title>Configurer <backrest/> pour utiliser plusieurs processus <cmd>backup</cmd></title>

            <backrest-config-option section="global" key="process-max">3</backrest-config-option>
        </backrest-config>

        <execute-list host="{[host-repo1]}">
            <title>Effectuer une sauvegarde avec plusieurs processus</title>

            <execute user="{[br-user]}">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=full backup</exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[host-repo1]}">
            <title>Obtenir des informations de sauvegarde pour l'instance {[postgres-cluster-demo]}.</title>

            <execute filter="n" output="y" user="{[br-user]}">
                <exe-cmd>{[project-exe]} info</exe-cmd>
                <exe-highlight>timestamp start/stop</exe-highlight>
            </execute>
        </execute-list>

        <p>La performance de la dernière sauvegarde devrait être améliorée en utilisant des processus multiples.  Pour les très petites sauvegardes, la différence ne sera peut-être pas très visible, mais plus la taille de la base de données augmente, plus le gain en temps est important.</p>
    </section>

    <!-- SECTION => START/STOP -->
    <section id="start-stop" depend="/repo-host/config">
        <title>Démarrer et arrêter</title>

        <p>Il est parfois utile d'éviter que <backrest/> ne fonctionne sur un système.  Par exemple, lors du passage d'un système primaire à un système de secours, il est préférable d'empêcher <backrest/> de fonctionner sur l'ancien système primaire au cas où <postgres/> serait redémarré ou ne pourrait pas être complètement détruit.  Cela empêchera également <backrest/> de fonctionner avec un lancement par le <id>cron</id>.</p>

        <execute-list host="{[host-pg1]}">
            <title>Stop the <backrest/> services</title>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} stop</exe-cmd>
            </execute>
        </execute-list>

        <p>Les nouveaux processus <backrest/> ne fonctionneront plus.</p>

        <execute-list host="{[host-repo1]}">
            <title>Tentative de sauvegarde</title>

            <execute user="{[br-user]}" err-expect="56" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} backup</exe-cmd>
                <exe-highlight>\: stop file exists for all stanzas</exe-highlight>
            </execute>
        </execute-list>

        <p>Précisez l'option <br-option>--force</br-option> pour mettre fin à tout processus <backrest/> en cours.  Si <backrest/> est déjà arrêté, un avertissement sera généré si vous l'arrêtez à nouveau.</p>

        <execute-list host="{[host-pg1]}">
            <title>Arrêter à nouveau les services de <backrest/></title>

            <execute user="postgres" output="y" filter="n">
                <exe-cmd>{[project-exe]} stop</exe-cmd>
            </execute>
        </execute-list>

        <p>Démarrer le processus <backrest/> à nouveau avec la commande <cmd>start</cmd>.</p>

        <execute-list host="{[host-pg1]}">
            <title>Démarrer les services <backrest/></title>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} start</exe-cmd>
            </execute>
        </execute-list>

        <p>Il est également possible de stopper <backrest/> pour une seule stanza.</p>

        <execute-list host="{[host-pg1]}">
            <title>Stoper le services <backrest/> pour le stanza <id>demo</id></title>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} stop</exe-cmd>
            </execute>
        </execute-list>

        <p>Les nouveaux processus <backrest/> pour le stanza spécifiée ne fonctionneront plus.</p>

        <execute-list host="{[host-repo1]}">
            <title>Tentative de sauvegarde</title>

            <execute user="{[br-user]}" err-expect="56" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} backup</exe-cmd>
                <exe-highlight>\: stop file exists for stanza demo</exe-highlight>
            </execute>
        </execute-list>

        <p>Le stanza doit également être spécifiée lors du lancement des processus <backrest/> pour un stanza unique.</p>

        <execute-list host="{[host-pg1]}">
            <title>Start the <backrest/> services for the <id>demo</id> stanza</title>

            <execute user="postgres">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} start</exe-cmd>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => REPLICATION -->
    <section id="replication" depend="/repo-host/perform-backup">
        <title>Replication</title>

        <p>La réplication permet de créer plusieurs copies d'une instance <postgres/> (appelé esclave ou standbys) à partir d'une seule primaire. Les standbys sont utiles pour équilibrer les lectures et pour fournir une redondance en cas de défaillance de l'hôte primaire.</p>

        <!-- SECTION => REPLICATION - INSTALLATION -->
        <section id="installation">
            <title>Installation</title>

            <p>Un nouvel hôte nommé <host>{[host-pg2]}</host> est créé pour ce rôle de standby (esclave).</p>

            <host-add id="{[host-pg2-id]}" name="{[host-pg2]}" user="{[host-pg2-user]}" image="{[host-pg2-image]}" os="{[os-type]}" mount="{[host-pg2-mount]}" option="{[host-option]}"/>

            <!-- <execute-list if="{[pg-version]} >= 11" host="{[host-pg2]}">
                <title>Create <user>{[br-user]}</user> user</title>

                <execute if="{[os-type-is-debian]}" user="root">
                    <exe-cmd>adduser {[dash]}-ingroup {[pg-group]} {[dash]}-disabled-password {[dash]}-gecos "" {[br-user]}</exe-cmd>
                </execute>
                <execute if="{[os-type-is-centos]}" user="root">
                    <exe-cmd>adduser -g{[pg-group]} -n {[br-user]}</exe-cmd>
                </execute>
            </execute-list> -->

            <block id="br-install">
                <block-variable-replace key="br-install-host">{[host-pg2]}</block-variable-replace>
                <block-variable-replace key="br-install-user">postgres</block-variable-replace>
                <block-variable-replace key="br-install-group">postgres</block-variable-replace>
            </block>
        </section>

        <!-- SECTION => REPLICATION - SETUP-SSH -->
        <section id="setup-ssh">
            <title>Configurer un accès SSH sans mot de passe</title>

            <block id="setup-ssh-intro">
                <!-- ??? Bogus variable is set because the syntax currently requires at least one -->
                <block-variable-replace key="bogus"></block-variable-replace>
            </block>

            <block id="setup-ssh">
                <block-variable-replace key="setup-ssh-host">{[host-pg2]}</block-variable-replace>
                <block-variable-replace key="setup-ssh-user">postgres</block-variable-replace>
                <block-variable-replace key="setup-ssh-user-home-path">{[pg-home-path]}</block-variable-replace>
            </block>

            <!-- <block if="{[pg-version]} >= 11" id="setup-ssh">
                <block-variable-replace key="setup-ssh-host">{[host-pg2]}</block-variable-replace>
                <block-variable-replace key="setup-ssh-user">{[br-user]}</block-variable-replace>
                <block-variable-replace key="setup-ssh-user-home-path">{[br-home-path]}</block-variable-replace>
            </block> -->
        </section>

        <!-- SECTION => REPLICATION - HOT-STANDBY -->
        <section id="hot-standby">
            <title>Hot Standby</title>

            <p>Un <quote>hot standby</quote> effectue la réplication en utilisant l'archive WAL et permet des requêtes en lecture seule.</p>

            <p>La configuration de <backrest/> est très similaire à celle de <host>{[host-pg1]}</host> sauf que le type de récupération <id>standby</id> sera utilisé pour maintenir l'instance en mode de récupération lorsque la fin du flux WAL aura été atteinte.</p>

            <backrest-config host="{[host-pg2]}" file="{[backrest-config-demo]}">
                <title>Configuration de <backrest/> sur l'escalve (standby)</title>

                <backrest-config-option section="demo" key="pg1-path">{[pg-path]}</backrest-config-option>

                <backrest-config-option section="global" key="repo1-host">{[host-repo1]}</backrest-config-option>

                <backrest-config-option section="global" key="log-level-file">detail</backrest-config-option>

                <backrest-config-option section="global" key="log-level-stderr">off</backrest-config-option>
                <backrest-config-option section="global" key="log-timestamp">n</backrest-config-option>
            </backrest-config>

            <p if="{[os-type-is-debian]}">L'instance de démonstration doit être créée (même si elle sera écrasée lors de la restauration) afin de créer les fichiers de configuration <postgres/>.</p>

            <execute-list if="{[os-type-is-debian]}" host="{[host-pg2]}">
                <title>Création de l'instance de démonstration</title>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-create]}</exe-cmd>
                </execute>
            </execute-list>

            <p if="{[os-type-is-centos]}">Créez le répertoire où <postgres/> sera restauré.</p>

            <execute-list if="{[os-type-is-centos]}" host="{[host-pg2]}">
                <title>Création du répertoire pour <postgres/></title>

                <execute user="postgres">
                    <exe-cmd>
                        mkdir -p -m 700 {[pg-path]}
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>Maintenant, l'escalve (standby) peut être créée avec la commande <cmd>restore</cmd>.</p>

            <execute-list host="{[host-pg2]}">
                <title>Restaurer le {[postgres-cluster-demo]} l'instance esclave (standby)</title>

                <execute user="postgres" if="{[os-type-is-debian]}">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta --type=standby restore</exe-cmd>
                </execute>

                <execute user="postgres" if="{[os-type-is-centos]}">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=standby restore</exe-cmd>
                </execute>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>cat {[postgres-recovery-demo]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Le paramètre <pg-setting>hot_standby</pg-setting> doit être activé avant de lancer <postgres/> pour autoriser les connexions en lecture seule sur <host>{[host-pg2]}</host>. Dans le cas contraire, les tentatives de connexion seront refusées.  Le reste de la configuration concerne le cas où l'instance esclave (standby) est promue comme primaire.</p>

            <postgres-config host="{[host-pg2]}" file="{[postgres-config-demo]}">
                <title>Configuration de <postgres/></title>

                <postgres-config-option key="hot_standby">on</postgres-config-option>
                <postgres-config-option key="archive_command">'{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} archive-push %p'</postgres-config-option>
                <postgres-config-option key="archive_mode">on</postgres-config-option>
                <postgres-config-option key="wal_level">{[wal-level]}</postgres-config-option>
                <postgres-config-option key="max_wal_senders">3</postgres-config-option>
                <postgres-config-option key="log_filename">'postgresql.log'</postgres-config-option>
                <postgres-config-option key="log_line_prefix">''</postgres-config-option>
            </postgres-config>

            <execute-list host="{[host-pg2]}">
                <title>Démarrage de <postgres/></title>

                <execute user="root" show="n">
                    <exe-cmd>rm {[postgres-log-demo]}</exe-cmd>
                </execute>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Le journal des traces <postgres/> donne des informations précieuses sur la récupération.  Notez en particulier que l'instance est entré en mode veille et est prête à accepter des connexions en lecture seule.</p>

            <execute-list host="{[host-pg2]}">
                <title>Examiner la sortie du journal de traces <postgres/> à la recherche des messages indiquant le succès</title>

                <execute user="postgres" output="y">
                    <exe-cmd>cat {[postgres-log-demo]}</exe-cmd>
                    <exe-highlight>entering standby mode|database system is ready to accept read only connections</exe-highlight>
                </execute>
            </execute-list>

            <p>Une façon simple de vérifier que la réplication est correctement configurée est de créer une table sur <host>{[host-pg1]}</host>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Créer une nouvelle table sur l'instance primaire</title>

                <execute user="postgres" output="y">
                    <exe-cmd>
                        psql -c "
                                 begin;
                                 create table replicated_table (message text);
                                 insert into replicated_table values ('{[test-table-data]}');
                                 commit;
                                 select * from replicated_table";
                    </exe-cmd>
                    <exe-highlight>{[test-table-data]}</exe-highlight>
                </execute>
            </execute-list>

            <p>Puis interrogez la même table sur <host>{[host-pg2]}</host>.</p>

            <execute-list host="{[host-pg2]}">
                <title>Intérroger la nouvelle table sur l'esclave (standby)</title>

                <execute user="postgres" output="y" err-expect="1">
                    <exe-cmd>psql -c "select * from replicated_table;"</exe-cmd>
                    <exe-highlight>does not exist</exe-highlight>
                </execute>
            </execute-list>

            <p>Alors, qu'est-ce qui a mal tourné ?  Puisque <postgres/> extrait des segments WAL de l'archive pour effectuer la réplication, les changements ne seront pas visibles en attente jusqu'à ce que le segment WAL qui contient ces changements soit poussé de <host>{[host-pg1]}</host>.</p>

            <p>Cela peut être fait manuellement en appelant <code>{[pg-switch-wal]}()</code> qui pousse le segment WAL actuel vers l'archive (un nouveau segment WAL est créé pour contenir les nouveaux changements).</p>

            <execute-list host="{[host-pg1]}">
                <title>Executer <code>{[pg-switch-wal]}()</code></title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "select *, current_timestamp from {[pg-switch-wal]}()";
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>Maintenant, après un court délai, la table apparaîtra sur <host>{[host-pg2]}</host>.</p>

            <execute-list host="{[host-pg2]}">
                <title>La nouvelle table existe maintenant sur l'esclave (standby) (peut nécessiter quelques essais)</title>

                <execute user="postgres" output="y" retry="15" filter="n">
                    <exe-cmd>psql -c "
                        select *, current_timestamp from replicated_table"</exe-cmd>
                    <exe-highlight>{[test-table-data]}</exe-highlight>
                </execute>
            </execute-list>

            <p>Vérifiez la configuration de l'esclave pour l'accès au dépôt de sauvegarde.</p>

            <execute-list host="{[host-pg2]}">
                <title>Contrôle de la configuration</title>

                <execute user="postgres" output="y">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info check</exe-cmd>
                    <exe-highlight>because this is a standby</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <!-- SECTION => REPLICATION - STREAMING -->
        <section id="streaming">
            <title>Réplication en flux contrinu flux (streaming replication)</title>

            <p>Au lieu de s'appuyer uniquement sur les archives de la WAL, la réplication en continu établit une connexion directe avec l'instance primaire et applique les modifications dès qu'elles sont effectuées sur la primaire. Il en résulte un délai beaucoup plus court entre le primaire et le secondaire (standby).</p>

            <p>La réplication en continu nécessite un utilisateur disposant du privilège de réplication.</p>

            <execute-list host="{[host-pg1]}">
                <title>Création d'un utilisateur de réplication</title>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>
                        psql -c "
                            create user replicator password 'jw8s0F4' replication";
                    </exe-cmd>
                </execute>
            </execute-list>

            <p>Le fichier <file>pg_hba.conf</file> doit être mis à jour afin de permettre à l'utilisateur de réplication utilisé sur l'instance esclave (standby) de se connecter.  Veillez à remplacer l'adresse IP ci-dessous par l'adresse IP réelle de votre <host>{[host-pg1]}</host>.  Un rechargement (reload) sera nécessaire après la modification du fichier <file>pg_hba.conf</file>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Création de l'entrée pour l'utilisateur de réplication dans <file>pg_hba.conf</file></title>

                <execute user="postgres">
                    <exe-cmd>
                        sh -c 'echo
                        "host    replication     replicator      {[host-pg2-ip]}/32           md5"
                        >> {[postgres-hba-demo]}'
                    </exe-cmd>
                </execute>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-reload]}</exe-cmd>
                </execute>
            </execute-list>

            <p>L'instance esclave (standby) doit savoir comment se connecter à l'instance primaire, pour ce faire, il faut configurer le paramètre <pg-option>primary_conninfo</pg-option> dans <backrest/>.</p>

            <backrest-config host="{[host-pg2]}" file="{[backrest-config-demo]}">
                <title>Paramètrage de <pg-option>primary_conninfo</pg-option></title>

                <backrest-config-option section="demo" key="recovery-option">primary_conninfo=host={[host-pg1-ip]} port=5432 user=replicator</backrest-config-option>
            </backrest-config>

            <p>Il est possible de configurer un mot de passe pour le paramètre <pg-option>primary_conninfo</pg-option> mais l'utilisation d'un fichier <file>.pgpass</file> est plus souple et plus sûre.</p>

            <execute-list host="{[host-pg2]}">
                <title>Configurez le mot de passe de réplication dans le fichier <file>.pgpass</file>.</title>

                <execute user="postgres">
                    <exe-cmd>
                        sh -c 'echo
                        "{[host-pg1-ip]}:*:replication:replicator:jw8s0F4"
                        >> {[postgres-pgpass]}'
                    </exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>chmod 600 {[postgres-pgpass]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Maintenant, l'instance esclave (standby) peut être créée avec la commande <cmd>restore</cmd>.</p>

            <execute-list host="{[host-pg2]}">
                <title>Arrêter <postgres/> et restaurer l'instance {[postgres-cluster-demo]} esclave (standby)</title>

                <execute user="root" err-suppress="y">
                    <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta --type=standby restore</exe-cmd>
                </execute>

                <execute user="postgres" output="y" filter="n">
                    <exe-cmd>cat {[postgres-recovery-demo]}</exe-cmd>
                </execute>
            </execute-list>

            <admonition type="note">Le paramètre <pg-setting>primary_conninfo</pg-setting> a été écrit dans le fichier <file>recovery.conf</file>.  La configuration des paramètres de récupération dans <backrest/> signifie que le fichier <file>recovery.conf</file> n'a pas besoin d'être stocké ailleurs puisqu'il sera correctement recréé à chaque restauration.  L'option <br-setting>{[dash]}-type=preserve</br-setting> peut être utilisée avec le <cmd>restore</cmd> pour laisser le fichier <file>recovery.conf</file> existant en place si ce comportement est préféré.</admonition>

            <p if="{[os-type-is-centos]}">Par défaut, {[user-guide-os]} stocke le fichier <file>postgresql.conf</file> dans le répertoire <postgres/> data.  Cela signifie que la modification apportée au fichier <file>postgresql.conf</file> seront écrasées par la dernière restauration et que le paramètre <pg-option>hot_standby</pg-option> doit être réactivé.  Les autres solutions à ce problème consistent à stocker le fichier <file>postgresql.conf</file> ailleurs ou à activer le paramètre <pg-option>hot_standby</pg-option> sur l'hôte <host>{[host-pg1]}</host> où il sera ignoré.</p>

            <postgres-config host="{[host-pg2]}" if="{[os-type-is-centos]}" file="{[postgres-config-demo]}">
                <title>Activation de <pg-option>hot_standby</pg-option></title>

                <postgres-config-option key="hot_standby">on</postgres-config-option>
            </postgres-config>

            <execute-list host="{[host-pg2]}">
                <title>Démarrage de <postgres/></title>

                <execute user="root" show="n">
                    <exe-cmd>rm {[postgres-log-demo]}</exe-cmd>
                </execute>

                <execute user="root">
                    <exe-cmd>{[pg-cluster-start]}</exe-cmd>
                </execute>

                <execute user="postgres" show="n">
                    <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
                </execute>
            </execute-list>

            <p>Le journal de traces <postgres/> confirmera que la réplication en mode flux continue (streaming réplication) a commencé.</p>

            <execute-list host="{[host-pg2]}">
                <title>Examen de la sortie des traces <postgres/> à la recherche des messages indiquant le succès</title>

                <execute user="postgres" output="y">
                    <exe-cmd>cat {[postgres-log-demo]}</exe-cmd>
                    <exe-highlight>started streaming WAL from primary</exe-highlight>
                </execute>
            </execute-list>

            <p>Désormais, lorsqu'une table est créé esur <host>{[host-pg1]}</host>, il apparaîtra sur <host>{[host-pg2]}</host> rapidement et sans qu'il soit nécessaire d'appeler la fonction SQL <code>{[pg-switch-wal]}()</code>.</p>

            <execute-list host="{[host-pg1]}">
                <title>Création d'une nouvelle table sur le primaire</title>

                <execute user="postgres" output="y">
                    <exe-cmd>
                        psql -c "
                                 begin;
                                 create table stream_table (message text);
                                 insert into stream_table values ('{[test-table-data]}');
                                 commit;
                                 select *, current_timestamp from stream_table";
                    </exe-cmd>
                    <exe-highlight>{[test-table-data]}</exe-highlight>
                </execute>
            </execute-list>

            <execute-list host="{[host-pg2]}">
                <title>Intéroger la table sur l'esclave (standby)</title>

                <execute user="postgres" output="y" retry="2" filter="n">
                    <exe-cmd>psql -c "
                        select *, current_timestamp from stream_table"</exe-cmd>
                    <exe-highlight>{[test-table-data]}</exe-highlight>
                </execute>
            </execute-list>
        </section>
    </section>

    <!-- SECTION => ASYNCHRONOUS ARCHIVING -->
    <section id="async-archiving" depend="/replication">
        <title>Archivage asynchrone</title>

        <p>L'archivage asynchrone est activé avec l'option <br-option>archive-async</br-option>.  Cette option permet un fonctionnement asynchrone pour les commandes <cmd>archive-push</cmd> et <cmd>archive-get</cmd>.</p>

        <p>Un chemin de file d'attente (spool) est nécessaire.  Les commandes stockent les données transitoires ici, mais chaque commande fonctionne de manière distincte, de sorte que l'utilisation du chemin d'accès à la file d'attente  (spool) est décrite en détail dans chaque section.</p>

        <execute-list host="{[host-pg1]}">
            <title>Créer le répertoire de file d'attente (spool)</title>

            <execute user="root">
                <exe-cmd>mkdir -p -m 750 {[spool-path]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chown postgres:postgres {[spool-path]}</exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[host-pg2]}">
            <title>Créer le répertoire de file d'attente (spool)</title>

            <execute user="root">
                <exe-cmd>mkdir -p -m 750 {[spool-path]}</exe-cmd>
            </execute>
            <execute user="root">
                <exe-cmd>chown postgres:postgres {[spool-path]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Le chemin de la file d'attente (spool) doit être configuré et l'archivage asynchrone activé.  L'archivage asynchrone apporte automatiquement un intérêt en réduisant le nombre de connexions au stockage distant, mais le réglage de <br-option>process-max</br-option> peut permettre d'améliorer considérablement les performances en parallélisant les opérations.  Assurez-vous de ne pas régler <br-option>process-max</br-option> à un niveau si élevé qu'il affecte les opérations normales de la base de données.</p>

        <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
            <title>Configurer le chemin du spool et l'archivage asynchrone</title>

            <backrest-config-option section="global" key="spool-path">{[spool-path]}</backrest-config-option>
            <backrest-config-option section="global" key="archive-async">y</backrest-config-option>
            <backrest-config-option section="global:archive-push" key="process-max">2</backrest-config-option>
            <backrest-config-option section="global:archive-get" key="process-max">2</backrest-config-option>
        </backrest-config>

        <backrest-config host="{[host-pg2]}" file="{[backrest-config-demo]}">
            <title>Configurer le chemin du spool et l'archivage asynchrone</title>

            <backrest-config-option section="global" key="spool-path">{[spool-path]}</backrest-config-option>
            <backrest-config-option section="global" key="archive-async">y</backrest-config-option>
            <backrest-config-option section="global:archive-push" key="process-max">2</backrest-config-option>
            <backrest-config-option section="global:archive-get" key="process-max">2</backrest-config-option>
        </backrest-config>

        <admonition type="note"><br-option>process-max</br-option> est configuré à l'aide de sections de commande de sorte que l'option ne soit pas utilisée par la sauvegarde et la restauration.  Cela permet également d'utiliser des valeurs différentes pour <cmd>archive-push</cmd> et <cmd>archive-get</cmd>.</admonition>

        <p>A des fins de démonstration, la réplication du streaming sera interrompue pour forcer <postgres/> à obtenir le WAL en utilisant la <pg-option>restore_command</pg-option>.</p>

        <execute-list host="{[host-pg1]}">
            <title>Interrompre la réplication du streaming en changeant le mot de passe de la réplication</title>

            <execute user="postgres" output="y" filter="n">
                <exe-cmd>
                    psql -c "alter user replicator password 'bogus'"
                </exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[host-pg2]}">
            <title>Redémarrer l'esclave (standby) pour interrompre la connexion</title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-restart]}</exe-cmd>
            </execute>
        </execute-list>

        <section id="async-archive-push">
            <title>Poussez les archives (Archive Push)</title>

            <p>La commande asynchrone <cmd>archive-push</cmd> décharge l'archivage WAL vers un (ou plusieurs) processus séparé(s) pour améliorer le débit. Elle fonctionne <quote>en regardant vers l'avenir</quote> pour voir quels segments WAL sont prêts à être archivés au-delà de la demande que <postgres/> fait actuellement via la commande <code>archive_command</code>. Les segments WAL sont transférés vers archivage directement depuis le répertoire <path>pg_xlog</path>/<path>pg_wal</path> et le retour de succès n'est renvoyé par l' <code>archive_command</code> que lorsque le segment WAL est réelement stocké en toute sécurité dans l'archivage.</p>

            <p>La file d'attente (spool) contient l'état actuel de l'archivage des WAL. Les fichiers d'état écrits dans le répertoire de spool sont généralement de longueur zéro et devraient consommer un minimum d'espace (quelques Mo au maximum) et très peu d'E/S.  Toutes les informations contenues dans ce répertoire peuvent être recréées, il n'est donc pas nécessaire de le préserver si l'instance est déplacé vers un nouveau matériel.</p>

            <admonition type="important">Dans l'implémentation initiale de l'archivage asynchrone, les segments WAL étaient copiés dans le répertoire spool avant la compression et le transfert.  La nouvelle implémentation copie le WAL directement à partir du répertoire <path>pg_xlog</path>.  Si l'archivage asynchrone était utilisé dans <proper>v1.12</proper> ou antérieur, lisez attentivement les notes de mise à jour de <proper>v1.13</proper> avant de procéder à la mise à niveau.</admonition>

            <p>Le fichier <file>[stanza]-archive-push-async.log</file> peut être utilisé pour surveiller l'activité du processus asynchrone.  Une bonne façon de tester cela est de pousser rapidement un certain nombre de segments WAL.</p>

            <execute-list host="{[host-pg1]}">
                <title>Tester l'archivage asynchrone parallèle</title>

                <execute user="postgres" output="n" show="n">
                    <exe-cmd>rm -f /var/log/pgbackrest/demo-archive-push-async.log</exe-cmd>
                </execute>

                <execute user="postgres" output="n">
                    <exe-cmd>
                        psql -c "
                            select pg_create_restore_point('test async push'); select {[pg-switch-wal]}();
                            select pg_create_restore_point('test async push'); select {[pg-switch-wal]}();
                            select pg_create_restore_point('test async push'); select {[pg-switch-wal]}();
                            select pg_create_restore_point('test async push'); select {[pg-switch-wal]}();
                            select pg_create_restore_point('test async push'); select {[pg-switch-wal]}();"
                    </exe-cmd>
                </execute>

                <execute user="postgres">
                    <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-log-level-console=info check</exe-cmd>
                    <exe-highlight>WAL segment</exe-highlight>
                </execute>
            </execute-list>

            <p>Le fichier journal (traces) contiendra désormais les activités parallèles et asynchrones.</p>

            <execute-list host="{[host-pg1]}">
                <title>Vérifier les résultats dans les traces.</title>

                <execute user="postgres" output="y">
                    <exe-cmd>cat /var/log/pgbackrest/demo-archive-push-async.log</exe-cmd>
                    <exe-highlight> WAL file\(s\) to archive|pushed WAL file \'0000000</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <section id="async-archive-get">
            <title>Obtention des archives (archive-get)</title>

            <p>La commande asynchrone <cmd>archive-get</cmd> maintient une file d'attente locale de WAL pour améliorer le débit.  Si un segment de WAL n'est pas trouvé dans la file d'attente, il est récupéré dans le dépôt avec suffisamment de WAL consécutifs pour remplir la file d'attente.  La taille maximale de la file d'attente est définie par la commande <br-option>archive-get-queue-max</br-option>.  Lorsque la file d'attente est moins de la moitié de sa capacité, un nombre plus important de WAL sera récupéré pour la remplir.</p>

            <p>Ce fonctionnement asynchrone est utile dans les environnements qui génèrent beaucoup de WAL ou qui ont une connexion à haute latence avec le stockage du dépôt (par exemple <proper>S3</proper> ou d'autres magasins d'objets).  Dans le cas d'une connexion à forte latence, il peut être judicieux d'augmenter <br-option>process-max</br-option>.</p>

            <p>Le fichier <file>[stanza]-archive-get-async.log</file> est utilisé pour surveiller l'activité du processus asynchrone.</p>

            <execute-list host="{[host-pg2]}">
                <title>Vérifier les résultats dans le journal des traces</title>

                <execute user="postgres" show="n">
                    <exe-cmd>sleep 5</exe-cmd>
                </execute>
                <execute user="postgres" output="y">
                    <exe-cmd>cat /var/log/pgbackrest/demo-archive-get-async.log</exe-cmd>
                    <exe-highlight>found [0-F]{24} in the archive</exe-highlight>
                </execute>
            </execute-list>
        </section>

        <execute-list host="{[host-pg1]}">
            <title>Régler le problème de la réplication par flux (streaming replication) en rechangeant le mot de passe de la réplication</title>

            <execute user="postgres" output="y" filter="n">
                <exe-cmd>
                    psql -c "alter user replicator password 'jw8s0F4'"
                </exe-cmd>
            </execute>
        </execute-list>
    </section>

    <!-- SECTION => STANDBY-BACKUP -->
    <section id="standby-backup" depend="/replication/streaming">
        <title>Sauvegarde depuis l'esclave (standby)</title>

        <p><backrest/> peut effectuer des sauvegardes depuis l'esclave (standby) au lieu de la sauvegarde depuis le primaire.  Les sauvegardes en attente nécessitent que l'hôte <host>{[host-pg2]}</host> soit configuré et que l'option <br-option>backup-standby</br-option> soit activée.  Si plus d'une instance esclave (standby) est configuré, c'est le premier en cours d'exécution trouvé qui sera utilisé pour la sauvegarde.</p>

        <backrest-config host="{[host-repo1]}" owner="{[br-user]}:{[br-group]}" file="{[backrest-config-demo]}">
            <title>Configuration de <br-option>pg2-host</br-option>/<br-option>pg2-host-user</br-option> et <br-option>pg2-path</br-option></title>

            <backrest-config-option section="demo" key="pg2-path">{[pg-path]}</backrest-config-option>
            <backrest-config-option section="demo" key="pg2-host">{[host-pg2]}</backrest-config-option>
            <!-- <backrest-config-option if="{[pg-version]} >= 11" section="demo"
                key="pg2-host-user">{[br-user]}</backrest-config-option> -->

            <backrest-config-option section="global" key="backup-standby">y</backrest-config-option>
        </backrest-config>

        <p>L'instance primaire et esclave (standby) sont toutes les deux nécessaires pour effectuer la sauvegarde, bien que la grande majorité des fichiers soient copiés à partir d'instance esclave afin de réduire la charge sur l'instance primaire.  Les instances de la base de données peuvent être configurés dans n'importe quel ordre.  <backrest/> déterminera automatiquement quelle est l'instance primaire et quelle est l'instance secondaire (standby).</p>

        <execute-list host="{[host-repo1]}">
            <title>Sauvegarde de l'instance {[postgres-cluster-demo]} depuis <host>pg2</host></title>

            <execute user="{[br-user]}" output="y" filter="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --log-level-console=detail backup</exe-cmd>
                <exe-highlight>backup file {[host-pg1]}|replay on the standby</exe-highlight>
            </execute>
        </execute-list>

        <p>Cette sauvegarde incrémentale montre que la plupart des fichiers sont copiés depuis <host>{[host-pg2]}</host> et que seuls quelques-uns sont copiés depuis <host>{[host-pg1]}</host>.</p>

        <p><backrest/> crée une sauvegarde depuis l'instance esclave qui est identique à une sauvegarde effectuée sur l'instance primaire.  Pour ce faire, il lance/arrête la sauvegarde sur l'hôte <host>{[hôte-pg1]}</host>, en copiant uniquement les fichiers qui sont répliqués à partir de l'hôte <host>{[hôte-pg2]}</host>, puis en copiant les quelques fichiers restants à partir de l'hôte <host>{[hôte-pg1]}</host>.  Cela signifie que les journaux et les statistiques de la base de données principale seront inclus dans la sauvegarde.</p>
    </section>

    <!-- SECTION => STANZA UPGRADE -->
    <section id="upgrade-stanza">
        <title>Mise à niveau de <postgres/></title>
        <cmd-description key="stanza-upgrade"/>

        <p>Les instructions suivantes ne se veulent pas un guide complet pour la mise à niveau de <postgres/>, mais elles décrivent plutôt le processus général de mise à niveau d'une instance <postgres/> primaire et d'une instance <postgres/> esclave (standb) dans le but de présenter les étapes nécessaires dans la reconfiguration de <postgres/>. Il est recommandé d'effectuer une sauvegarde avant la mise à niveau.</p>

        <execute-list host="{[host-pg1]}">
            <title>Arrêter la vieille instance</title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Arrêtez l'instance esclave (standb), car elle sera restaurée à partir de la l'instance nouvellement mise à niveau.</p>

        <execute-list host="{[host-pg2]}">
            <title>Arrêter la vieille instance</title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-stop]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Créer une nouvelle instance et effectuer la mise à niveau.</p>

        <execute-list host="{[host-pg1]}">
            <title>Créer une nouvelle instance et effectuer la mise à niveau</title>

            <execute user="postgres">
                <exe-cmd>
                    {[pg-bin-upgrade-path]}/initdb
                        -D {[pg-path-upgrade]} -k -A peer
                </exe-cmd>
            </execute>

            <execute user="root" if="{[os-type-is-debian]}">
                <exe-cmd>{[pg-cluster-create-upgrade]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y" if="{[os-type-is-debian]}">
                <exe-cmd>sh -c 'cd /var/lib/postgresql &amp;&amp;
                        /usr/lib/postgresql/{[pg-version-upgrade]}/bin/pg_upgrade
                            {[dash]}-old-bindir=/usr/lib/postgresql/{[pg-version]}/bin
                            {[dash]}-new-bindir=/usr/lib/postgresql/{[pg-version-upgrade]}/bin
                            {[dash]}-old-datadir={[pg-path]}
                            {[dash]}-new-datadir={[pg-path-upgrade]}
                            {[dash]}-old-options=" -c config_file={[postgres-config-demo]}"
                            {[dash]}-new-options=" -c config_file={[postgres-config-demo-upgrade]}"'
                </exe-cmd>
                <exe-highlight>Upgrade Complete</exe-highlight>
            </execute>

            <execute user="postgres" output="y" if="{[os-type-is-centos]}">
                <exe-cmd>sh -c 'cd /var/lib/pgsql &amp;&amp;
                        /usr/pgsql-{[pg-version-upgrade]}/bin/pg_upgrade
                            {[dash]}-old-bindir=/usr/pgsql-{[pg-version]}/bin
                            {[dash]}-new-bindir=/usr/pgsql-{[pg-version-upgrade]}/bin
                            {[dash]}-old-datadir={[pg-path]}
                            {[dash]}-new-datadir={[pg-path-upgrade]}
                            {[dash]}-old-options=" -c config_file={[postgres-config-demo]}"
                            {[dash]}-new-options=" -c config_file={[postgres-config-demo-upgrade]}"'
                </exe-cmd>
                <exe-highlight>Upgrade Complete</exe-highlight>
            </execute>
        </execute-list>

        <p>Configuration des paramètres et du port de la nouvelle instance.</p>

        <postgres-config host="{[host-pg1]}" file="{[postgres-config-demo-upgrade]}">
            <title>Configuration de <postgres/></title>

            <postgres-config-option key="archive_command">'{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} archive-push %p'</postgres-config-option>
            <postgres-config-option key="archive_mode">on</postgres-config-option>
            <postgres-config-option key="wal_level">{[wal-level]}</postgres-config-option>
            <postgres-config-option key="max_wal_senders">3</postgres-config-option>
            <postgres-config-option key="listen_addresses">'*'</postgres-config-option>
            <postgres-config-option key="log_line_prefix">''</postgres-config-option>
            <postgres-config-option key="port">5432</postgres-config-option>
        </postgres-config>

        <p>Mettez à jour la configuration <backrest/> sur tous les systèmes pour pointer vers la nouvelle instance.</p>

        <backrest-config host="{[host-pg1]}" file="{[backrest-config-demo]}">
            <title>Mise à jour de <br-option>pg1-path</br-option></title>

            <backrest-config-option section="demo" key="pg1-path">{[pg-path-upgrade]}</backrest-config-option>
        </backrest-config>

        <backrest-config host="{[host-pg2]}" file="{[backrest-config-demo]}">
            <title>Mise à jour de <br-option>pg-path</br-option></title>

            <backrest-config-option section="demo" key="pg1-path">{[pg-path-upgrade]}</backrest-config-option>
        </backrest-config>

        <backrest-config host="{[host-repo1]}" owner="{[br-user]}:{[br-group]}" file="{[backrest-config-demo]}">
            <title>Upgrade <br-option>pg1-path</br-option> and <br-option>pg2-path</br-option>, disable backup from standby</title>

            <backrest-config-option section="demo" key="pg1-path">{[pg-path-upgrade]}</backrest-config-option>
            <backrest-config-option section="demo" key="pg2-path">{[pg-path-upgrade]}</backrest-config-option>

            <backrest-config-option section="global" key="backup-standby">n</backrest-config-option>
        </backrest-config>

        <execute-list host="{[host-pg1]}">
            <title>Copie de la configuration hba</title>

            <execute user="root">
                <exe-cmd>cp {[postgres-hba-demo]}
                    {[postgres-hba-demo-upgrade]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Avant de lancer la nouvelle instance, la commande <cmd>stanza-upgrade</cmd> doit être exécutée sur le serveur où se trouve le dépôt <backrest/>.</p>

        <execute-list host="{[host-repo1]}">
            <title>Mise à niveau du stanza</title>

            <execute user="{[br-user]}" output="y">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-no-online
                    {[dash]}-log-level-console=info stanza-upgrade</exe-cmd>
                <exe-highlight>completed successfully</exe-highlight>
            </execute>
        </execute-list>

        <p>Démarrer la nouvelle instance et confirmer qu'il est installé avec succès.</p>

        <execute-list host="{[host-pg1]}">
            <title>Démarrage de la nouvelle instance</title>

            <execute user="root" output="y">
                <exe-cmd>{[pg-cluster-start-upgrade]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Controler la configuration en utilisant la commande <cmd>check</cmd>.</p>

        <execute-list host="{[host-pg1]}">
            <title>Controle de la configuration</title>

            <execute user="postgres" output="y" filter="n">
                <exe-cmd>{[pg-cluster-check-upgrade]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y" filter="n">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} check</exe-cmd>
            </execute>
        </execute-list>

        <p>Supprimer l'ancienne instance.</p>

        <execute-list host="{[host-pg1]}">
            <title>Suppression de l'ancienne instance</title>

            <execute if="{[os-type-is-debian]}" user="root">
                <exe-cmd>pg_dropcluster {[pg-version]} {[postgres-cluster-demo]}</exe-cmd>
            </execute>

            <execute if="{[os-type-is-centos]}" user="root">
                <exe-cmd>rm -rf {[pg-path]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Installer la nouvelle version des binaire de <postgres/> sur l'esclave (standby) et créer l'instance.</p>

        <execute-list host="{[host-pg2]}">
            <title>Supprimer l'ancienne instance et créer une nouvelle instance</title>

            <execute if="{[os-type-is-debian]}" user="root">
                <exe-cmd>pg_dropcluster {[pg-version]} {[postgres-cluster-demo]}</exe-cmd>
            </execute>

            <execute if="{[os-type-is-centos]}" user="root">
                <exe-cmd>rm -rf {[pg-path]}</exe-cmd>
            </execute>

            <execute user="postgres" if="{[os-type-is-centos]}">
                <exe-cmd>
                    mkdir -p -m 700 {[pg-bin-upgrade-path]}
                </exe-cmd>
            </execute>

            <execute user="root" if="{[os-type-is-debian]}">
                <exe-cmd>{[pg-cluster-create-upgrade]}</exe-cmd>
            </execute>
        </execute-list>

        <p>Exécuter la commande <cmd>check</cmd> sur l'hôte du dépôt. L'avertissement concernant l'instance esclave est attendu puisque l'instance est en panne. L'exécution de cette commande permet de démontrer que le serveur de dépôt est conscient de l'existance d'un serveur esclave et que <backrest/> est bien configuré pour l'instance primaire.</p>

        <execute-list host="{[host-repo1]}">
            <title>Controle de la configuration</title>

            <execute user="{[br-user]}" output="y" filter="n" >
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} check</exe-cmd>
            </execute>
        </execute-list>

        <p>Effectuez une sauvegarde complète sur la nouvelle instance, puis restaurez la sur l'instance secondaire (standby)  à partir de cette sauvegarde. Le type de sauvegarde sera automatiquement changé en <id>full</id> si <id>incr</id> ou <id>diff</id> est demandé.</p>

        <execute-list host="{[host-repo1]}">
            <title>Démarrage d'une sauvegarde complète</title>

            <execute user="{[br-user]}">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-type=full backup</exe-cmd>
            </execute>
        </execute-list>

        <execute-list host="{[host-pg2]}">
            <title>Restauration de {[postgres-cluster-demo]} sur l'instance esclave</title>

            <execute user="postgres" if="{[os-type-is-debian]}">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} {[dash]}-delta --type=standby restore</exe-cmd>
            </execute>

            <execute user="postgres" if="{[os-type-is-centos]}">
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} --type=standby restore</exe-cmd>
            </execute>
        </execute-list>

        <postgres-config host="{[host-pg2]}" file="{[postgres-config-demo-upgrade]}">
            <title>Configuration de <postgres/></title>

            <postgres-config-option key="hot_standby">on</postgres-config-option>
        </postgres-config>

        <execute-list host="{[host-pg2]}">
            <title>Démarrer <postgres/> et controler la configuration de <backrest/></title>

            <execute user="root">
                <exe-cmd>{[pg-cluster-start-upgrade]}</exe-cmd>
            </execute>

            <execute user="postgres" show="n">
                <exe-cmd>{[pg-cluster-wait]}</exe-cmd>
            </execute>

            <execute user="postgres" output="y" filter="n" >
                <exe-cmd>{[project-exe]} {[dash]}-stanza={[postgres-cluster-demo]} check</exe-cmd>
            </execute>
        </execute-list>

        <p>La sauvegarde à partir de l'esclave peut être activée maintenant que cette esclave a été remis en place.</p>

        <backrest-config host="{[host-repo1]}" owner="{[br-user]}:{[br-group]}" file="{[backrest-config-demo]}">
            <title>Réactivation de la sauvegarde depuis l'esclave</title>

            <backrest-config-option section="global" key="backup-standby">y</backrest-config-option>
        </backrest-config>
    </section>
</doc>
